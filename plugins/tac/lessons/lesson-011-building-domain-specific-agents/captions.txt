Agentic engineering leads every
engineer down one single
path. Better agents, more
agents, and then custom
agents. If you can
prompt engineer and context
engineer a single agent
successfully, then the next
step is to add
more agents. Scale your
compute to scale your
compute to scale your
impact. Then once you
learn to delegate work
to sub agents and
new primary agents, there's
only one place left
to go, custom agents.
But why? Isn't Claude
Code, Codex CLI, the
Gemini CLI enough. The
out-of-the-box agents are incredible,
but there's a massive
problem with these tools.
They're built for everyone's
codebase, not yours. This
mismatch can cost you
hundreds of hours and
millions of tokens, scaling
millions of tokens, scaling
as your codebase grows.
This lesson is about
flipping that equation. Here,
we master custom agents
so your compute works
for your domain, your
problems, your edge cases.
This is where all
the alpha is in
engineering. It's in the
hard specific problems that
most engineers and most
agents can't solve out
of the box. You
can't walk up to
these problems and solve
them without unique domain
knowledge. And custom agents
knowledge. And custom agents
let you pass your
domain specific unique knowledge
right to your agents.
Custom agents let you
do a few special
things. You can take
the core four context,
model, prompt, and tools
and scale them beyond
the defaults. You can
solve domain specific problems
with targeted repeatable workflows.
Custom agents also let
you protect protect your
codebase, protect your
assets, and protect other
engineers from agents calling
the wrong tools at
the wrong time. Ultimately,
the wrong time. Ultimately,
custom agents let you
take two tactics of
Agentic Coding to their
limit. They let you
template your engineering, directly
into your agent and
they push the one
agent, one prompt, one
purpose tactic to its
limits. And sometimes it's
not about building 100%
custom agents at all.
By knowing how to
use programmatic agents like
the ClaudeCode SDK, you
can deploy out of
the box agents like
ClaudeCode programmatically and just
make a few tweaks
make a few tweaks
so that it performs
better for your use
case. You don't always
have to reinvent the
agent from zero. In
this advanced lesson and
we showcase eight unique
custom agents built on
the Claude Code SDK,
each one showing you
how to deploy across
your stack, products, and
engineering lifecycle. The agents
are on the horizon.
It's time to master
agents by going all
the way to the
bare metal, to the
custom agent, so you
can scale your compute
far beyond the rest.
far beyond the rest.
As usual, we're gonna
start simple and progress
through more capable agents
step-by-step so you can
understand how to build
these from zero. In
the building specialized agents
codebase, inside of
apps, you can see
eight custom agents. We're
gonna break down. Some
of these have multiple
agents embedded within each.
Let's start simple with
the Pong agent. So
the Pong agent. So
here's a simple agent
that's gonna showcase the
most important aspect of
custom agents. You can
see we have a
simple, concise user prompt
and agent response, and
we have some session
stats. Let's run this
again, all right? Let's
go ahead and change
our prompt. Hello, simple
prompt. We're just getting
started with custom agents.
I said hello, it
just responded with Pong,
okay? Summarize this code
base. Okay, there's my
user prompt. And once
again, the Pong agent
is responding again with
Pong. What's going on
here? Let's ask it
here? Let's ask it
what's happening. Can you
do anything other than
Pong? Okay, there's a
user prompt and okay.
So all this agent
does is Pong. type
one more here. I'm
just going to write
king. This silly agent
encapsulates the most important
concept when you're building
custom agents. No matter
what we prompt here,
the response is always
pong. Why is that?
Let's dive into this
file. So the first
most important concept is
none other than the
system prompt. We are
using the Claude Code
SDK and we're setting
SDK and we're setting
up only two things.
We're modifying just two
aspects of this agent,
but it changes everything.
So you can see
Cloud4Sonnet and here the
system prompt. So let's
open up the system
prompt. You can see
we have this dedicated
load system prompt method.
There's the path to
the prompt. Let's open
it. We have completely
overwritten the Claude Code
system prompt with this
title of our agent
purpose. And we have
a simple three line
instruction. You are a
Pong agent, always respond
Pong agent, always respond
exactly with Pong. That's
it. The system prompt
is the most important
element of your custom
agents. with zero exceptions.
We are modifying the
core for specifically the
prompt. But now we
have two very important
prompts to pay attention
to, system prompts and
user prompts. The system
prompt affects every single
user prompt the agent
runs every single one.
So all of your
work is multiplied by
your system prompt. So
how does the Cloud
Code SDK work? Let's
Code SDK work? Let's
go ahead and break
down the key ideas.
The SDK works like
this. You set up
your options, you set
up your agent. Here
we're just running the
query and then you
handle the response. The
Claude Code SDK is
a powerful tool for
putting together agents. As
you'll see, as we
progress, all the pieces
are there and they're
incrementally adoptable. And then
lastly, we're just doing
some logging. That's it.
of our agent, right?
A simple 150 line
Pong agent. Most of
this is just logging.
We're setting up the
agent. We're then querying
the agent, we're then
handling the response of
handling the response of
the agent. And take
note of these specific
blocks that you can
report. We have our
agent message blocks, we
have a result message,
and you can parse
specific information out of
these as you'll see
as we progress. But
this is the Pong
agent, and this showcases
the power of the
system prompt. Remember, all
that work that the
Claude Code team has
put into making a
great agent, right? The
Claude Code agent that
you know and love
is now gone. Okay,
you have to be
very careful with the
system prompt. We now
system prompt. We now
have a new product.
This is not clog
code anymore. Okay, might
be using the same
model, but the system
prompt is truly what
builds the agent. Now,
of course, we are
still using the tools.
That's important to call
it here. As you'll
see, as we progress
into more and more
capable custom agents, let's
move on to our
second agent, the Echo
agent. Inside of our
echo agent, you can
see a similar structure.
We have a single
Python script here that
we're gonna execute, uv
run echo agent py.
run echo agent py.
And we're gonna see
a similar structure, right?
We have our echo
agent kicking off, user
prompt, agent response, but
here we have something
different. Here we have,
of course, a custom
tool. So our agent
is saying, I'll use
this tool, and then
we have this tool
call block here, and
then we have the
response of the tool
call, and then our
agent response, right? So
these are all unique
elements coming out of
our agent. You wanna
be keeping track of
these, right? Keep track
of the core four.
If you understand the
core four and how
each element flows and
each element flows and
controls your agent, you
will understand compute and
you'll understand how to
scale your compute. Let's
go ahead and echo
ourselves. So I'm gonna
say echo this string
and then I want
it in reverse in
uppercase. Repeat two times.
Here we're just playing
with the tool that
our custom agent has.
All right, so there's
the user prompt, there's
that call. In reverse,
this text comes out
to custom agents are
powerful. We ask it
to repeat. repeat and
go uppercase. So that's
exactly what our agent
has done. Okay. We're
scaling up a little
more. We're adding a
few more capabilities to
few more capabilities to
our agent as we
explore custom agents. Let's
understand what's going on
here in the echo
agent, same structure. I
always love collapsing everything.
And you can just
quickly understand what's going
on. We have main,
we have a tool
and we have our
system prompt. Always look
for the system prompt
and then look for
the custom tools. We
have a couple of
parameters here. Then we
have something special. So
once again, you can
always just search cloud
code options. We have
an MCP server built
in this script, create
SDK MCP server, and
SDK MCP server, and
we're passing in a
single tool. So this
builds an entire MCP
server in memory for
our agent. This is
super powerful. So let's
look at our echo
tool and understand what
it does. Tools for
your Claude Code SDK,
they're built like this,
a decorator. We then
have the name, we
have the description, So
keep in mind, The
description of your tool
tells your agent how
to use it in
addition to the actual
parameters that get passed
into your tool. In
the actual arguments, you
just pass in a
dict and then you
do whatever you want
do whatever you want
to do inside of
your tool. Here we
step back into traditional
deterministic code, right? It's
a tool call. Do
whatever you want, but
be sure to respond
in the proper format.
You can see here,
here's our log. Here's
the transforms we were
doing, right? Just a
small example tool call
for our agent. This
is a custom agent
with a custom custom
tool set. Now, something
interesting here as well,
you can see we're
running Claude Haiku. We
have downgraded our model
to a cheaper, less
intelligent, but much faster
model, right? This is
a simple agent. It
a simple agent. It
doesn't need powerful intelligence.
So we've dropped down
the model. As you
progress through each agent,
keep in mind, we
have the 12 leverage
points of agentic coding
that we're paying attention
to. But whenever you
see Claude Code options,
isolate the core four.
How will the core
four be managed given
this setup? Now we
have something else here
that's important to call
out. We're using the
Claude SDK client class
instead of our pong
agent where we were
just using that query
command. All right. So
query is for one
off prompts and the
off prompts and the
Claude SDK client is
for continuous conversations. Let
me show you exactly
what I mean here.
Let's clear this and
let's run this once
again with follow up.
So if we kick
this off, our agent
is going to run
that same prompt like
normal, but then it's
going to continue the
conversation. We're going to
pass in another follow
up prompt, I'm gonna
say concisely summarize our
conversation in bullet points.
And so here it
is, right? Our agent
quickly responds, follow up
response, concise summary, one,
two, three, four. Our
agent has kept track
of the conversation because
of the conversation because
we're using the Claude
SDK client and because
we've written multiple query
calls. You can see
we have two here,
follow up prompt and
the original user prompt,
all right? So we
have both the tool
use block that we
care about and we
have the text block.
You can stream all
the messages coming back
out from your agent
after you query and
just take them in,
right? Take them in,
do whatever you want
with them. Here, of
course, we're just logging
with clean, rich panels,
concisely communicating what's happening
with our agent. If
you don't know what
your agent is doing,
if you don't adopt
if you don't adopt
your agent's perspective, it
will be hard to
improve them and tweak
them and manage them.
So that's what we're
doing here. And you
can see the followup
prompt. We fired off
that additional query. and
we just looked for
that one response, right?
We're looking for a
tool use block and
really we only were
looking for the text
block here, right? This
is not actually that
useful. This is a
customization with a few
more capabilities, right? We've
specified the model, we've
given it a custom
tool to work with,
but here's something interesting
that if you're using
these agents left and
these agents left and
right, you probably haven't
been paying attention to.
If we run this
same agent and we
just drop everything down
here and we just
say list your available
tools. we are actually
still running a lot
of the Claude code
baked in tool set.
So check this out,
right? These are all
the Claude code tools
plus our tool. And
so everything that's going
into your agent winds
up in the context
window at some point.
We have 15 extra
tools, 15 extra options
tools, 15 extra options
that our agent has
to choose from and
select to do the
job we've asked it.
Now our Echo agent,
does not need any
of these tools. All
right. And so as
we progress, we're going
to find to and
we're going to get
more control over our
agent. If you ever
run the slash context
commander, understand what's going
into your agent. You
know that these 15
tools consumes context. It
consumes space in your
agent's mind. We're going
to learn how to
control that knob in
our next agent. The
last thing we want
to point out here
is our echo system
prompt. Okay. Very simple.
prompt. Okay. Very simple.
Right? Again, it's important
to call out, this
is not the Claude
Code product anymore. As
soon as you touch
the system prompt and
once you start dialing
into the tools, you
change the product, you
change the agent. All
right? So you can
see here, title, purpose,
Echo agent use the
tool when asked. All
right. So there's not
a lot happening here,
but there is a
lot that was happening
that isn't happening anymore.
Right. If that makes
sense, we have blown
away the Claude Code
system prompt. We have
completely overwritten it. Now,
it is important to
it is important to
mention you can append
system prompt. Right, you
can just add on
to what's already there.
This is also powerful.
This is more of
a way to extend
Claude Code versus overwrite
it and build a
true custom agent, right?
Let's continue, let's progress,
let's get more control
over agents. Let's scale
this up and let's
look at a new
form factor for agents
because right now all
we're doing is firing
off one off scripts.
Next, we have the
Next, we have the
calc agent, very similar
structure. You can see
we're consistently using that
prompts directory. Let's get
a little meta. As
I was working on
this and building this,
right, all these agents
with agents, I'm using
a leverage point of
agentic coding, I'm using
consistent codebase architecture
you can see same
structure same format we
have that prompts directory
and every one of
our custom agents we're
being consistent with our
codebase it's easy
for us to read
it's easy for our
team to read and
it's easy most importantly
it's easy most importantly
for our agents to
read let's run the
calc agent and understand
what this does for
us by the way
uvr is uv run
i'll be using this
as a shorthand calc
agent py kick it
off and What do
we have here? Our
calc agent puts the
custom agent in a
different form factor. One
you're familiar with the
terminal UI. Let's just
start by asking what
tools do you have
available? So there's a
user prompt. And of
course we're not going
to get a agent
response here. Gave us
this long response, show
tool names only. Okay.
tool names only. Okay.
So these are the
tools, the only tools
this agent has. So
in contrast, to our
Echo agent, our calculator
agent only has these
two tools, okay? This
is a fine-grained focused
agent. Very clearly you
can see we have
a different agent experience,
we have a different
agent interface. Okay. Before
we were running scripts
throughout tack, we ran
80 W's, which are
scripts in our new
agentic layer. That's great
for true engineering workflows.
Most agents for engineers
Most agents for engineers
will be deployed in
a script somewhere, but
you can also use
agents in terminal UIs,
right? You can build
up your own personalized
version of really any
terminal based application. And
then of course, as
we'll progress, you can
build up full agents
as backend methods and
as data streamers and
data Anyway, let's focus
here, calculator agent. Let's
do some calculations, right?
55 Fahrenheit to Celsius.
So we have the
converter here. It is
converted that for us,
right? So user prompt
right? So user prompt
came in, we called
the tool right away
and the agent has
responded to us, right?
Two decimal places, looks
great. 125 meters to
millimeters. Again, using that
custom converter there, it's
being very concise with
its response. It's just
giving me the answer
I'm looking for, right?
A fine-tuned calculator agent.
I know, still simple,
but we're working working
up to more complexity,
stacking it on. I
want you to understand
the primitives. Primitive understanding
is critical for scaling
up what you can
do. Don't start with
big things, start with
big things, start with
small things, right? Everything
large is a few
small things that you
understand fundamentally first. Okay,
great, so we have
this tool called, let's
run the other tool,
right? This is just
our unit converter. Let's
run something like this,
right? Best deal, 500K
home at 5% or
600K at 4%. It's
gonna take a little
bit more thought here
from our agent. So
let's see what it
does here. Agent response,
there's a tool call.
Here's another tool call.
Running it again over
30 years, you'd save
XYZ, approximately save XYZ
with the home at
500K at 5% interest,
500K at 5% interest,
okay? Again, just showcasing
a simple example in
agent, fine-tuned, customized to
do one thing very
well. Let's break down
this agent, all right?
Calc agent. You can
see a couple things
right away. I'm already
at the sweet spot
here. Cloud code options.
We have our built-in
MCP server with our
specific allowed but the
most important part here
is this. At the
beginning we ran list
all tools, it only
had our two tools,
right? We can keep
asking, right? List available
tools, again, function name,
tools, again, function name,
and params only. So
our agent is going
to think a little
bit and give us
this response. There it
is. There is our
exact tools. Okay. So
you can see here
we have this big
disallow tools block. Our
agent is specifically not
allowed to use these
tools. These tools do
not end up in
its context window. Very
important. This is not
an option, right? There's
no read option for
it anymore. They can't
see this. Okay. You
always have to adopt
your agent's perspective. The
Claude Code options is
how you understand your
how you understand your
agents core for minus
the user prompt, right?
The user prompt comes
in via our client
dot query. All right.
And of course here
we are focused on
the Claude Code SDK.
Every other agent SDK
will have some version
of this. All right.
So yes, We are
big Claude Code fans
and yes, we will
always use the best
tool for the job
and we think bigger
than single tools, right?
This is not about
a single tool. This
is about the best
tool for the job
and understanding agents and
custom agents at large,
custom agents at large,
right? The big idea,
the abstract idea. So
you can see here,
right? We have our
disallowed tools there. That's
great. We have our
system prompt, all right?
So we have our
calculator prompt. Again, system
prompt, full overwrite, right?
This is not Cloud
Code anymore. We have
the model and then
we have a resume,
right? We were passing
back in the current
session ID. This is
important. We have a
couple of tools here.
Let's just go ahead
and quickly understand our
tools, quickly collapse everything.
You can see everything
in this file, we
have 400 lines. In
the calculate expression, you
can see just based
can see just based
on the tool, right?
The tool decorator, we
have custom math, perform
mathematical calculations, expression, precision.
All right, not a
lot happening here. We're
running the eval to
do some math. In
your tools, you're back
in deterministic world. Do
whatever you want. Just
set up the input
and set up the
output properly. And if
something goes wrong, communicate
that back to your
agent. Your agent can
pivot, right? This is
part of the advantage
of scaling LLMs into
prompt chains and then
into agents. They can
reflect, improve, change, but
reflect, improve, change, but
you have to to
give them the information,
all right? This is
the equivalent of the
standard out plus tools
in our 12 leverage
points, right? You need
to give your agent
back information. If an
error occurs, can our
agent pivot? So this
is a question you
can ask and build
in to your system
so that your agent
has the information it
needs to pivot to
success within its tools,
within its agent loop.
So this is our
tool here. And of
course, you can see
that down here inside
of our tools, inside
of this in-memory MTP
server. And these are,
server. And these are,
of course, our only
allowed tools. Now, we
are using the powerful
CloudForce Sonnet. If you're
operating in the future,
hopefully you have something
more powerful, but don't
let these models fool
you. It's not the
models that are the
limitation, the bottleneck anymore.
It's you and I.
It's our ability to
wield better agents, more
agents, and now custom
agents. Okay, we have
this new current session
ID. This is important.
Let's go ahead and
understand how this works.
And just to mention
it again, right? Same
workflow. You set up
your options with the
Claude Code options. This
basically configures your core
basically configures your core
for you then set
up the SDK. So
we're mounting the agent
with the options and
then you run your
prompt. You then manage
the responses. Your agent
is going to do
work for you. Do
you know what it
is? You know this
by managing its responses.
All right. So you
can see here we
have two unique messages,
assistant message and result
message. Now, these might
change. in the future,
right? It's very likely
these change. The key
idea is that you
understand how to manage
the primitives of your
custom agent. If we
look at this, our
result message is giving
us session ID or
we can get our
we can get our
total costs here. This
is just information on
the message when you're
operating a result message,
okay? And so we
use this to continue
the session. Right. And
that's what this resume
parameter does. So we
can just keep prompting
back and forth. We
have our own micro
agent that we can
chat to in the
terminal over and over
and over. Okay. So
this is a form
factor you can use.
Of course, after you
finish this lesson, everything
is going to be
available to you in
this codebase. It's
going to help you
quick start building your
own custom agents and
understanding what you can
understanding what you can
do with custom agents.
All right. So this
is great. It's also
really important to call
out these SDKs, specifically
the Claude Code SDK.
It has built in
prompt caching. So you
will be saving money.
by using this out
of the box, right?
By just tuning and
tweaking your custom agent
with the Claude Code
SDK. Let's scale up.
Let's move on to
more capable agents and
look at an interesting
and on-tapped use case
of agents. Next we
have our social hype
agent. We're starting to
build up a more
interesting, more complex, kind
interesting, more complex, kind
of built out code
base. We're adding complexity
as we add capabilities
to our agent. Let's
just go ahead and
kick this off and
understand how this works.
UVR, social hype agent.
We're gonna kick off
our social hype agent
and notice here we're
passing in keywords and
then we're going to
run this dash n
which is a notification
prompt any mention of
new language model releases
any mention of hacking
prompting or educational posts
surrounding these companies okay
let's fire this off
and let's understand what's
happening here so this
is not a terminal
interface this is not
a script this is
a script this is
a stream handler so
we're looking at the
blue sky fire hose
web socket it's blasting
out events to this
service from this web
socket and then we're
looking for specific keywords.
This is just a
terminus of code, right?
That's not new. That's
not interesting. This is
a simple string contains
check, but what is
interesting here, our agent
is now going to
pick up the keywords
and then run a
sentiment analysis. So check
this out. Claude Code,
integration news, Zencoder adding
support for Claude Code
and other CLI coding
and other CLI coding
agents. Perfect, okay, right
on topic, right on
topic. I was a
little worried when I
ran this, you know,
during this lesson that
we get some not
so clean outputs here,
but so far so
good. New OpenAI tech
release. OpenAI partners with
Joni Ive on AI
devices with ChatGPT for
2.026 launch. And I'll
just pause here for
now, right? So you
can see how the
system works top to
bottom. That was perfect.
We got a couple
runs, couple executions. and
we looked at some
5,000 messages from this
WebSocket firehose. All right,
what is our agent
doing? You can see
doing? You can see
tool called. We always
know when our agents
are calling tools. I
highly recommend you build
out logging observability with
your agent responses so
that you can understand
what's happening and when
it's happening. Submit analysis.
Anytime our keyword matches
via deterministic code, our
agent is kicking off
and is doing a
sentiment analysis with the
submit analysis tool call.
Then if it finds
a message that matches
our notification process, that
we passed in at
the start, right? If
we hit up here,
you can see that
exact notification prompt. It
will then kick off
an alert to us.
an alert to us.
It's a tool call,
so you can do
anything you want, right?
In our case, we
spun up a Apple
script that showed that
notification, and then we
fired off a natural
language text-to-speech that just
spoke the title and
the message. So in
the background live, you
know, this service could
be running anywhere. It
could be texting you.
It could be updating
a Discord, a Slack
group, whatever, giving critical
information in a live
fashion based on some
data stream, right? In
this case, we're just
quickly looking at the
blue sky fire hose,
but this could be
any endpoint, any web
any endpoint, any web
socket, any RSS feed,
anything you want it
to be, right? This
is an interesting form
factor for agents. They
can stream and process
information for you. They
can process the natural
language and determine if
something is happening based
on your interests. You
can see here, we
have a more built
up codebase, but
it all starts here.
social hype agent, open
a main initial setup.
And then we have
a monitoring loop. Let's
go ahead and dive
into this, collapse everything
here. You can see
here it has several
methods. The most important
one is monitor. There's
our web socket. There's
our worker. And inside
our worker. And inside
of our worker, we
are firing off. We
should be able to
see that pretty soon
here. Queue task, filtering
the content. And if
we have a match
keyword, we increase our
match. We create this
object and then we
put it on a
queue. Of course, what
does our queue do?
You could guess exactly
what this does. Our
queue kicks off. You
guessed it. If we
open up Analyze and
Notify, we can see
here, we have a
Claude Code SDK client.
All right, so you
can always just search
for these inside this
codebases to understand
where your custom agents
are getting set up.
So first things first,
So first things first,
check out the options.
This is our custom
agent that we've built
from scratch to be
a great data analysis
for this stream of
information. That's a specific
use case, right? A
specific problem that we're
processing. What's the system
prompt, right? All this
is important, but the
most important thing by
far is your agent
system prompt. What's the
law that you're your
agent obeys, what's the
high level objective, what
is the purpose of
your agent that will
affect every single user
prompt, right? That's why
prompt, right? That's why
you always focus here.
First, let's open up
social hype system prompt.
Once again, look at
the directory structure, nice
and clean, very consistent.
We want consistent code-based
architecture for our agents,
for ourselves, for our
teams, all right? Come
to the prompt. collapse
everything, we can see
a more built out
prompt structure. If you've
taken the agentic prompt
engineering extended lesson inside
of agentic horizon, you
know exactly what this
is and what the
structure is and why
it's valuable. Let's go
ahead and take a
look at the purpose
analyzing real time process
analyzing real time process
streaming accurate summaries classified,
determine when to warrant
a user notification. Okay,
so we're just operating
on a live stream
of data. This is
a data streaming agent
and we're doing something
really cool here inside
of our system prompt,
we're passing in a
variable much like our
user prompts, but of
course these aren't running
over and over and
over. We can't dynamically
use this. So the
moment we set this
up, it's locked in,
which is perfect for
our use case, right?
As long as this
agent runs, I just
want it to look
want it to look
for this, okay? And
so we can encode
that in the system
prompt This is to
be clear, a static
variable that is dynamically
updated, right? This can't
run multiple times. It
runs a single time,
right? This updates to
whatever my prompt was
at runtime when I
kick up this agent
and that's it, right?
Not to be confused
with true dynamic variables
for Claude Code, you
would run something like
this, right? Dollar sign
argument or dollar sign
one, right? This is
a dynamic variable. Every
time the user prompt
runs, this will get
updated. This is not
updated. This is not
a user prompt. This
is a system prompt.
This is the law
for the agent. always
run with this exact
same setup. We're going
to do a quick
replace on this. You
can just search this
and see exactly where
that's happening. Load system
prompt. Let's move into
this. And then we
have that getting templated
right there. Right? So
exactly as you would
expect inside of our
utils, we have a
little bit more structure
in this codebase.
All right. We have
a nice set of
instructions. All right. So
we can just collapse
at the third level
here. And we also
have a workflow. Now,
Controversially, we're putting the
workflow right inside the
workflow right inside the
system prompt. Why is
that? It's because we
always want this agent
to do the same
thing over and over,
okay? So you can
embed workflows in your
system prompt if you're
sure that that is
what you want to
happen every single time
your agent executes, all
right? The Claude Code
system prompt does not
have a workflow like
this because it's a
generic multi-purpose engineering agent.
But we're building a
social hype agent, right?
We have a specific
use case, a specific
domain problem, and we
know the workflow. So
know the workflow. So
we can put it
in the system prompt.
It's the law. We
always want this to
happen. You can see
the instructions there. I'm
not gonna dive into
these too much. The
one important thing to
mention is that inside
your system prompt in
some capacity, I recommend
having a tool usage
requirements slash usage guide
that helps further guide
your tool usage. That's
happening here. Summary sentiment
keyword, optionally use notify
when it meets the
notification criteria, right? Which
we pass in right
here. So this is
the system prompt. This
is the law for
the agent. We then
have the model. We
have the model. We
have our tools. We
have that submit analysis
tool. and a notify
tool. We're not going
to dive into those.
You can imagine what
they're doing. And then
again, importantly, we're clearing
the agent out, right?
I don't need these
capabilities. Your agent doesn't
need the capabilities. Get
it out of the
context window. Remember, this
all ends up in
the context window, all
right? So we're clearing
out our agent. We're
letting our agent focus,
right? One agent, one
prompt, one purpose, a
max of three turns.
And then we're just
doing deterministic code stuff.
Let's move on to
our responses. You can
see here we have
several different response blocks,
several different response blocks,
assistant messages, and we
have result messages. And
then in our assistant
messages, we have a
text block, the tool
use block, and the
tool result block. And
so we're just processing
all that. As you
saw here, we can
just kick this off
again and let it
stream a few more.
This is a data
streaming agent. It's handling
this for us. You
can imagine this running
on a log stream,
you know, some live
feed that is critical
for your engineering success
and reporting to you,
reporting via a user
interface, you know, hint,
hint. I'm excited to
share that one with
you here, but let's
you here, but let's
go ahead and continue.
You can see here,
we're not getting any
notifications, but our agent
is processing this one
match item so far
because we saw, looks
like we saw a
cloud here, GPT, right?
user message, of course,
all anonymized. Let's proceed
to our next powerful
agent. So what's a
QA agent? How does
this work? What's going
on here? This agent
kicks things up a
notch. Let's go ahead
and just fire this
up. UVRQA agent.py. You
can see here we
are back in the
terminal. We have a
terminal interface. This agent
terminal interface. This agent
is a specialized agent.
It is veering into
that advanced context engineering
capability. This agent is
an expert. Check out
the elite context engineering
extended lesson to understand
agent experts at a
deeper level. We have
a simple version of
an agent expert here.
Let's break it down.
This is a code
base question and answer
system. So you can
imagine this being useful
for, of course, understanding
the codebase for
getting new engineers ramped
up for performing engineers,
just understanding how to
build out a new
feature. So list all
your tools. from your
your tools. from your
system prompt. And you
can see here we
have a new message
type. This is the
system message. So we
have some really important
information here. You can
see all the tools
available right away. And
you can see our
MCP server. We are
also using the Firecrawl
MCP server here, right?
So this agent is
connected to and runs
the Firecrawl MCP server.
So your custom agents
can access MCP servers
just like your in-loop
agents can. So you
can see here, it's
got a nice summary
of all the tools
show in bullets, name
show in bullets, name
only. Check this out.
We have 13 tools
and you can see
which tools specifically are
enabled for our code-based
QA agent. task, bash,
glob, grep, read, some
web searching and some
fire call searching. We
probably don't need both
of these web searching,
but I wanted to
add these as fallbacks
for you if you
come in here and
you don't have the
fire call MCP server
set up. So summarize
the key way agent,
think hard. We're gonna
tap in to the
agent's reasoning capabilities. There
you can see we
have a thinking response
block that we're parsing.
There's the read, there's
our tool audit. We
are auditing its tools,
right? We have governance
and permission checks built
into the agent. And
you can see here,
it has read that
file. It's understanding it.
It's breaking it down
for us here. Tool
management, rich UI, Claude,
SDK integration, security features.
There it is. There's
our nice summary. We
have more important agents
to get to, but
you can see how
valuable this can be
for yourself, for new
engineers, and for planning
upcoming features, we have
a codebase QA
agent dedicated, specialized for
agent dedicated, specialized for
operating this small code
base right here. Okay,
how does this work?
QA agent, let's open
it up. Let's collapse
everything that's got a
high level view, 570
lines, main. You can
always just look and
search for the key
pieces of information. We
don't have any tools,
so no custom tools
here, but we can
of course search Claude
and we're taken right
to the most important
element of Claude Code
custom agents using the
Claude Code SDK. We
have the options, right?
This is where we
This is where we
declare the majority of
the core four. And
so we have a
new addition here. We
have some hooks. We
have our resumes. We're
gonna continue the conversation.
Of course, we're explicitly
declaring the model. We're
getting rid of some
tools. We're allowing some
other tools. And most
importantly, above all, we
have our own system
prompts. Understand the system
prompt. QA agent system
prompt. Look at that
consistent codebase. Once
again, no confusion anywhere
over and over and
over and over. Once
you find the winning
patterns, keep using them
patterns, keep using them
collapse. And you can
see we have a
nice codebase architecture
here. We are using
two against slightly controversial
sections. They're not really
that controversial, but your
system prompt will just
always be this way,
right? For every agent
execution. So you need
to be absolutely sure
this is what you
want your agent to
see every time it
runs, right? This is
the law for your
agent. Your system prompt
is the law for
your agent. Let's understand
the purpose of this
agent, understand answer questions,
functionality, leveraging parallel search,
functionality, leveraging parallel search,
capabilities, intelligent analysis, right?
So instructions, you can
see a whole set
of instructions here. Let's
go ahead and collapse
this to the third
level. Three sections of
instructions. We have our
current working directory with
some information about this
codebase the agent's
operating in. And then
we have agent examples.
All right, so agent
examples are powerful for
letting your agent know
exactly how to respond,
right? So you can
see this is just
a couple back and
forth question answers for
your agent. And this
is always in the
system your agent always
knows how to respond.
knows how to respond.
Okay, so that's the
system prompt. So in
our loud tools, you
can see we aren't
creating an MCP server,
but we are extending
it, right? We have
this MCP config path.
This is super important.
Let's go ahead and
look at this. We
are actually referencing this
fire call MCP server.
And I think this
is actually 6K. tokens
consumed, fire crawl, 6K.
And our agent is
indeed referencing that. So
if we just search
for fire crawl, you
can see this right
here, load MCP config,
there's that MCP config
path. And then we
are just checking that
we're adding an MCP
we're adding an MCP
server. So this is
an important capability. You
can build custom agents
and you can tap
into the rich model
context protocol ecosystem. A
lot of the tools
that you'll want and
need already exist. We
have that resume so
we can continue conversations.
We have our allowed
tools, which are specific
code-based searching tools, right?
This agent cannot write.
It's a QA agent.
Why would it need
to write anything? So
we are making that
clear in our tools,
right? Remember the core
four, context, model, prompt,
tools, custom agents, Let
tools, custom agents, Let
you control all of
these very quickly and
quickly. consistently, right? This
is encoded, right? This
is quite literally in
code. So our agent
will always perform this
way. That's our allowed
tools, disallowed tools. And
then we have something
special here. We have
hooks. If you've used
Claude Code hooks, you
know exactly what this
is. This is how
we can tap into
the permission system. So
we're blocking environment variable
files. We have two
matches here, pre-tool use,
post-tool use. Here we're
just doing some logging,
right? Log tool usage.
We're just calling this
method. That's what these
do. These just point
do. These just point
to specific methods. And
then in pre-tool use,
this is where things
interesting hooks. Of course,
we're just logging usage,
but here in our
hook matcher, when we
match the read command,
block environment variable files.
All right, we don't
want this to happen.
And we can of
course just test this,
read the dot in
file, right? And pay
attention to what happens
here. Our agent is
going to think, but
there we go, blocked
access to this environment
variable. It tried to
read the sample, which
we should allow, but
this custom agent doesn't
care. It blocks everything.
care. It blocks everything.
All right, so now
it's just reporting that.
And yeah, so it
can see its own
code. So it's spoiling
the fun here, but
you can see there
our hook blocked reading
dot M in the
file path, right? blocked
it completely and we
gave it a concise
response format telling it
exactly why it was
blocked, all right? And
then we have warnings
for other types of
files. You can do
anything you want in
your hook file, much
like you can with
your tools. But this
is important. You can
tap into the hook
capabilities with your custom
agents. You can see
here, this is essential
here, this is essential
for governance, for control,
for permissions in all
of your agents. We
can ask questions, we
can let it search.
It runs multiple agents
to get things done
quickly. Feel free to
use this as a
starting point for your
own code-based QA agent.
Let's move on to
richer applications where we
embed our agents into
user experiences. Next we
have a try copy
writer. And now we
have a more built
out structure, backend, frontend,
prompts. We have this
fired up here and
fired up here and
let me just go
ahead and clear this
out and restart this.
And we have our
backend, we have our
frontend. Let's go ahead
and understand what this
interface is, all right?
So this is a
try copy writer. We're
now moving our agents
into user interfaces. So
I'll just start by
typing hi and you
can see something interesting
right out of the
box. We have one
agent generating a response
with six variations. multi-variation
copywriter agent. I have
with one prompt, six
variations coming out of
this agent. All right,
very powerful, but it's
even more capable than
that. Okay, I can
that. Okay, I can
drag and drop a
file and load this
as context. This is
the script from the
Elite Context Engineering extended
lesson. And I'll just
say, write a blog
post title for our
script between 30 and
60 chars. And so
one prompt is getting
scaled up by our
agent. So try to
guess how exactly we're
doing this, how we're
making this work. But
you can see here
one prompt generates six
variations. This is a
copywriting machine, right? A
lot of writing, a
lot of thinking, a
lot of creating is
lot of creating is
about filtering out many
variations, many futures, many
possibilities for the thing
you're trying to create.
The try copywriter lets
us pick the number
of versions we generate
and then we can
just ask for copy,
right? We can just
generate copy. We can
push it even further,
four section blog outline,
one sentence description each,
right? So I wanna
just get some ideas
flowing on this new
blog that I'm writing
and I can use
this agent specialized for
copywriting to help me
accomplish that, right? So
now I'm gonna get
a four section blog
outline with one sentence
outline with one sentence
and subscription each, six
versions to quickly look
through and pile through
and use for my
writing, right? Use for
my work. Just another
example of how you
can embed unique agents,
right? Custom agents and
get value out of
them. Check this out.
We have six versions.
It's in Markdown. So
of course, another place
to take this application.
We can set up
Markdown, blah, blah, blah,
boring UI stuff, but
you understand the capability
here, right? You understand
how powerful this can
be as you start
moving our agents into
UIs, right? Which will
UIs, right? Which will
likely be where they're
most deployed. How does
this work? What is
going on here, right?
You can see our
costs there, not too
bad considering we're writing
six versions. Let's understand
our try copy agent.
Perfect. We're already there.
First place to go
is plot SDK client
and specifically options. This
is a fairly simple
agent. We just have
a system prompt, of
course, most important model,
resume ID, and then
we have every tool
disallowed. Okay. So this
agent can only respond
via its agent response.
via its agent response.
I don't want any
tools running here. I
don't care about tool
calling here for this
problem, for this use
case, tool calling is
useless for me. This
does not provide value
to our users, to
our customers in this
specific use case, but
we do have this
system prompt. And let's
go and open this
up, right? If we
collapse as normal, we
have the following. Purpose,
variables, instructions, examples. If
you're noticing a pattern,
that's good. You're understanding
what's going on here.
And this is actually
wrong here. This is
a bug. You're a
copywriter that responds with
number of versions, unique
number of versions, unique
versions. There you go.
It started with three
and then I bumped
it up to number
of versions. You can
dynamically select how many
versions your agent responds
with, all right? Number
of versions, we pass
this into the system
prompt and lock it
into stone, right? We
turn it into the
law of the agent,
okay? Then we have
our instructions, respond JSON,
variations, blah, blah, blah.
The most important part
is down here, right?
Examples, here's what the
output structure looks like.
We have the primary
response and we have
our multi-version copy responses.
Okay. And so it
is important from a,
you know, prompt engineering
you know, prompt engineering
application perspective. It is
important that this agent
can see every variation.
Otherwise you need to
coordinate multiple agents to
get this done by
using the system prompt
and by building a
custom agent, every unique
version can come right
out of this one
agent. And that means
that it has all
that context, right? It
has those tokens inside
of its context window.
So when it's generating
the unique versions, it
can generate them properly.
And you know, I
left another bug in
here, my bad. Let's
just search for three.
Okay, there we go.
So that was the
last one. So here
last one. So here
we of course just
referencing this variable that
we're declaring at the
top of the file,
powerful language models will
be able to reference
this and know exactly
what we mean here.
All right, so fantastic.
So this is the
system prompt, this controls
the behavior of our
agents, I highly recommend
whatever response format you
return from your agents
if you're responding with
JSON, you create a
concrete object. If we
search that here, you
can see we have
this in a field,
right? In a Pydantic
class. If you're in
TypeScript land, you'll use
Zod, but here we
use Pydantic, all right?
So response format, multi-version
So response format, multi-version
copy response, you can
see it right here.
We're of course processing
this, copying it out
when the time is
right. So this is
that agent. There's really
not much else going
on here. We are
starting to deploy agents
in user interfaces as
backend API methods, right?
This is all called
from, we should get
like slash something, yeah,
slash copy returns multiple
copy variations. And so
you can just trace
all this back, await,
generate copy, blah, blah,
blah, blah, all set
up. And at some
point we're going to
get to the most
get to the most
important piece, which is
right here, our agents
options, which then gets
passed into our agents
SDK, which then gets
queried on. And so
same deal, right? You
set up the options,
you set up the
agent, you query, and
then you manage the
responses. Here's our assistant
block. Here's our result
block where we're managing
session ID costs, so
on and so forth.
Assistant message, all we
care about is the
text block. Okay, let's
move on to our
next powerful agent. Now
we arrive at custom
seven micro SDLC agent.
seven micro SDLC agent.
Let's understand the structure
of this codebase.
back end, front end,
reviews, specs, and a
couple of test files.
So let's go ahead
and just kick this
off. We already have
this running here, back
end, front end. Let's
see exactly what this
is. You probably understand
what's going on here,
right? We have an
agent by agent task
board where we hand
off work from one
agent to another agent
in a kind of
micro software development life
cycle. Now you can
see here, we have
a couple of tasks
already shipped. We have
some aired ones over
here. Let's just go
here. Let's just go
ahead, create a new
task, we're gonna do
something really stupid and
simple. I just wanna
showcase the workflow and
showcase the capabilities that
you can build into
your user interfaces with
agents. So update titles,
this is just gonna
be super simple, update
the HTML title and
header title to be
plan, build, review, and
ship agents. Okay, and
now we have that
here, right, update titles,
and then we just
drag it into plan.
And now this workflow
is gonna kick off,
let's go ahead and
refocus on the actual
agent running on the
agent running on the
back So let's just
collapse the front end
there and let's see
what our agent is
doing. The difference here
is we have a
multi-agent system, right? We're
not just deploying a
single agent anymore. We're
deploying multiple agents inside
of our UI. So
now we have a
planner agent. It's noticing,
it's thinking, right? We
have planner thinking, planner
tool calls, hook, interceptions,
right, tool allowed, we
have permission system inside
of this, it has
the full structure. And
now it's gonna start
updating this code, right?
It's a simple title
change, this isn't rocket
change, this isn't rocket
science, but we should
see our title update
here. And we should
see our HTML title
update as well, right?
It is operating on
itself. Couple of cool
things, right? You can
kind of build out
your own multi-agent orchestration
system, however you want.
We have the messages
on the left, so
the total messages getting
streamed to the front
end via WebSockets. And
then we have the
total tool calls on
the right. Okay, so
our agent is working.
You can see there
the planning is incrementing,
but you can see
here our builder agent
is now processing. And
this is really cool,
this is really cool,
right? Our build agent
is now processing. So
the planner is done.
You'll notice the UI
is gonna be a
little kind of glitchy
here because it is
updating on itself. And
so it's actively starting
and restarting the server
and the client, but
that's fine. Our web
socket should pick this
up and continue processing.
So there you can
see the spec. We're
operating on that plan.
We're operating in the
review now. So if
I hit refresh, there
we go. We can
see that we're in
the review step now.
Okay, so. Very cool
way to just kind
of see how agents
can work together and
then you just package
it in a nice
UI. Then you can
UI. Then you can
do more than you
ever could before, frankly,
right? We have a
dedicated workflow working step
by step by step,
plan, build, review, and
handing it off to
the next stage in
the process, okay? You
can see here our
reviewer agent, there's all
of its tools, and
you can see it
just operating, doing work
for us, right? We're
using a lot of
the out-of-the-box Claude Code
tools, right? If you
don't need to reinvent
the wheel, don't do
it. Let's be super
clear about this. The
Claude Code, running the
base Claude Code agent
is incredible. We've been
using it since Claude
using it since Claude
Code was released. You
can see here, we
just moved to shipped.
There we go, update
titles. And you can
see here, guess what
happened? Plan, build, review,
and ship agents. Both
titles updated. This work
shipped with a single
prompt outside the loop,
right? This is a
perfect example of an
out loop review system
using the Peter framework,
right? Our tickets are
our prompt input and
review system. We dialed
into this a ton
inside of TAC. If
you haven't finished the
TAC lessons, you should
probably stop watching this
probably stop watching this
video immediately and finish
TAC. It's all about
transitioning from in loop
to out loop. to
eventually ZTE. We have
a couple of cool
things to point out.
So seven slash main,
let's get into custom
micro seven and just
collapse, right? Let's understand
this at a fundamental
level, scroll to the
bottom here, 400 lines
front end. And I
think we have a
couple additional files here.
Yeah, we have our
modules, agent orchestrator and
just a config file,
right? I don't think
any of this here
is interesting. What is
interesting is the agent
orchestrator. So let's come
in here and let's
in here and let's
just search our cloud
code options, right? This
is a great place
to start when you're
just quickly looking through
agents and you want
to know where to
start. So we have
the following configuration. Super
important here, we do
have hooks. So we
are limiting our agent.
We're giving our planner
agent a right hook.
And we're basically just
saying, where is it
exactly? We're saying a
normalized path here. We're
getting the path to
whatever it's trying to
write to. And we're
making sure that our
writer agent can only
write to our plan
directory. There is no
other reason for a
planner to do anything
else. So we're making
else. So we're making
sure with permission checks
via hooks. You saw
that throughout, write aloud
when our spec was
trying to get written
right here, right? And
we can of course
open up the spec.
It should just be
in the specs directory
right here. There we
go. And you can
see exactly what this
is, right? So it
just wrote up this
nice spec here. This
is a plan. So
it doesn't really follow
any traditional prompt engineering,
agentic prompt engineering structure,
but this is just
a plan to get
work done, right? It's
a plan to operate
and ship. You can
see here, probably a
little bit overkill, 175
lines, but still good
to have, right? We
have a full plan.
have a full plan.
We have a trail
of success. in our
codebase from planning
to building to reviewing.
We also have in
this micro SDLC a
review file here as
well. So our agent
not only planned, it
wrote a review for
us as well. So
that's fantastic. And let's
get back to our,
where did that go?
Agent orchestration, right? So
we have this tool
here, right? Planner right
hook, fantastic. And this
is one of our
agents configurations. We can
of course go into
our planner prompt and
see exactly what our
planner is doing. There's
the planner prompt. And
here we also have
here we also have
individual user prompts that
we're passing in as
well. So we have
planner user prompt. Okay,
you can see the
structure here, system prompts,
and we have user
prompts. So we're separating
our prompts, we're creating
dedicated spaces. These aren't
custom slash commands. These
are dedicated prompts, we
could for sure make
these custom slash commands,
but for the SDLC,
it's much easier to
just have concrete files
that we then replace,
okay? Classic agentic prompt
format here for prompts
going into your agentic
coding tools. We have
the title, the purpose,
the title, the purpose,
variables, instructions, workflow, report,
so on and so
forth. We're not gonna
dive into these, we
gotta keep moving, but
you can guess how
the other agents look,
right? If we just
search this, We have
another agent here. This
is our builder and
we don't need to
modify anything here, right?
We don't have a
new system prompt. We
are using the Claude
Code engineering agent, all
right? So, you know,
don't feel pressured to
overwrite the system prompt.
So here we have
the model, current working
directory, permission mode. We're
letting our builder agent
do whatever it needs
do whatever it needs
to, to ship. And
of course we have
the resume ID here.
We don't need it
because we're just firing
off one agent, one
prompt, one purpose. But
if we needed to,
we could resume the
conversation for user interface
purposes, right? Although with
these larger building and
planning steps, you don't
want your custom agents
running the compat command
behind your back because
the context got too
large. That will create
outcomes that are much
harder to trace. Hence
the big idea, one
agent, one prompt, one
purpose. And our reviewer
is doing something interesting.
is doing something interesting.
It's appending its system
prompt to the clawed
code system, okay? So
we're not blowing it
away We're just adding
something, all right? I'm
gonna leave this all
here for you to
check out and to
understand. We have a
multi-agent workflow wrapped in
a UI. We are
extending Claude Code in
most cases, modifying a
couple things, adding some
permission checks, some hooks.
In our planner agent
and in our review
agent, we're just appending
system prompt. So this
is an important idea.
You don't always need
to blow away the
Claude Code system prompt,
all right? So very
all right? So very
powerful. This is of
course a demo. This
isn't gonna work in
all cases, but you
have this available. to
you to test out,
to understand how you
could build something like
this. Let's move on
to our final agent,
the UltraStream agent. Our
final agent looks like
this. Similar structure, backend,
data front end modules,
system prompts, and we
have a couple of
test files. We have
some data here. Let's
understand this server, kick
off the backend. Once
again, I'm gonna run
with reset so that
with reset so that
it clears out the
current database. We have
two agents. We have
our streaming agent on
the right and we
have our chat interface
on the left. And
as you can see
here, our streaming agent
is a live process
feed of incoming logs.
So you can imagine
a log file coming
in from your backend,
Datadog, GCP, AWS, wherever
you handle your logs,
Just intake that information
and let your agent
process on it and
filter for important information
like this alert. All
right. Just by sitting
here in this UI,
I got this alert.
The streaming agent is
The streaming agent is
summarizing the logs. It's
understanding the logs, it's
ingesting them. And it's
letting me know if
there's something that needs
my attention. We have
an alert here. So
I can dial into
this with our inspector
agent on the left.
I'll say a list
issues one through three
log summary only and
user. So we're taking
that off. And of
course, our agent is
looking at this formatted
data. It's calling its
own tool set built
up for this specific
use case, right? This
domain specific use case.
And then it's outputting
some markdown here for
some markdown here for
us, all right? So
we have the severity
here, a summary, and
then the user in
which it was responsible
for, right? Very cool,
very interesting, all right?
And so we actually
just missed log four,
so include, log four
and just show summary
user. There is our
tool read. It's reading
from this data stream.
And there are a
couple really, really important
pieces here happening with
this application, right? There's
the severity. And then
we can do something
like this, right? We're
in this domain specific
application where we have
application where we have
agents working for us.
Alert support about issue
number four. While we're
doing this, you can
see another high issue
is gonna come in
here. Our agent is
gonna let us know
that there's a new
alert. So there's another
issue for us to
process. But you can
see here, right, we
have notified our support
team about this issue,
okay? You can imagine
your support has this,
And it's the other
way around, right? Support's
letting the engineering team
know, engineering teams letting
PM know, whatever. You
can literally do anything
under the sun. The
important thing here is
we have two agents
helping us operate a
stream of important information,
stream of important information,
helping us filter it
down piece by piece
by piece. All right,
how are we able
to build this powerful,
rich user experience, a
multi-agent experience? Let's go
and close this. This
is my favorite agent
combination, by the way.
And why is that?
Why is this my
favorite? It's because it's
really showcasing the fact
that you can use
agents, not just in
UI, in operating data
streams. You can produce
outputs with one agent
and have other agents
like the inspector agent
consume the output as
its input from another
agent, right? There's just
so many multi-agent configurations
so many multi-agent configurations
that are untapped and
unexplored. So this is
all under a single
file, which is probably
not correct since we're
up at 1,400. So
this is gonna be
harder for an agent
to read, but you
can see here, not
too bad either, right?
We have concrete headers.
That'll be a little
bit easier to understand
and read if we
need to quickly filter
through and search through
what exactly the application
is doing. But anyway,
we can of course
search at tool to
find all of our
tools. And more importantly,
we can search for
Claude Code options. We
have custom agents, right?
have custom agents, right?
From the ground up,
these are full custom
agents. We have the
system prompt, which I
always recommend you throw
the system prompt at
the top here. So
I'm going to move
that. System prompts, we've
disallowed every other tool,
right? This is not
a Claude Code agent
at all. We don't
need those tools at
all. We need our
specific tools, all right?
So here's our stream
agent and check out
what this can do.
Read stream file, produce
summarize log, create alert.
This agent is just
constantly processing these log
messages for us. Summarizing,
it's pulling important information.
It's letting us know
if there are issues
if there are issues
we should get to.
The most important thing
here is that, you
know, this is operating
on what could be
an insurmountable log file.
If we go into
data, open up our
stream log here, and
imagine the stream log
is coming from anywhere,
right? We have 42,000
tokens. This will be
much, much bigger as
your data streams in
from whatever service you're
working with. Right now,
our agent is obviously
operating on this file.
It could be many,
many times larger than
its context window. In
fact, if we threw
fact, if we threw
all of these logs
in here at the
same time, it would
not be able to
process them without taking
a lot of time,
a lot of tokens,
and that means a
lot of capital. But
we of course have
built fine-grained tools to
help our agent operate
this specific use case.
You cannot do this
without serious prompt engineering
with a out of
the box agent. Okay,
we have a tool
for this domain specific
Saving money, saving tokens,
saving time. Start line
index, inline index, you
can see our agent
is processing logs and
chunks, right? So we're
chunks, right? So we're
just incrementing 45 through
50. If we go
back up, you can
see 40 through 45,
35 through 40. So
we are reading just
a few lines and
processing just a few
lines. We're not overwhelming
our agents. We're constantly
thinking from our agent's
perspective. And you can
see here, here's how
we're doing it. We're
processing that very quickly
using a sub process
command. And that just
gets the work done
for us on this
file, cleaning up old
cache entries, so on
and so forth. All
right, feel free to
dive into the code
more. I just wanna
point out this fact
point out this fact
that we are building
a specialized agent to
operate on a file
in a token efficient
way, okay? So that's
our stream agent. And
we can of course
see all the tools
getting built up here.
It's then producing a
summarized log one piece
at a time. If
we open up our
stream agent system prompt,
you can see here,
we have a couple
of static variables. We
could dynamically set these
static variables, but these
are just purely static.
We're letting our agent
manage its own context
window. with this variable
that updates some code
that clears the context
window by updating the
window by updating the
session ID. We have
lines to read and
then once again, rinse
and repeat, right? Whatever
you want your agent
to do, detail it
in the specific agentic
prompt format, the agentic
system prompt format. Specifically,
we have the workflow,
we have instructions, variables,
purpose. You can imagine
what this all does.
The workflow is important
here because again, we
have a specific workflow.
We want our agent
to hit every single
time. We're giving it
some examples, right? This
is an important section
that you can swap
into your agentic prompts,
both system prompt and
user prompt. And we're
user prompt. And we're
showing it how to
produce the right log
formats. You can see
exactly what this looks
like, capture the information
that you care about,
and then pass it
onto the tool. All
right, there's that workflow,
right? So we're just
being super clear about
what's next. So this
is our stream agent.
We also have our
inspector agent. This agent
operates on the logs,
right? It operates on
the logs produced by
our stream agent. So
we're gonna read produced
log entries. Same kind
of format, right? Whatever
we prompted to read,
start index and end
index, as you saw
here, and it looks
like we ran into
like we ran into
some issue. Let's go
ahead and restart the
server. We can also
find logs for a
specific user based on
the information that we're
processing based on our,
again, domain specific problem.
I really wanna showcase
that that is the
key of custom agents.
You can solve your
problems better than any
agent can. Okay, out
of the box is
a great place to
start, but don't end
there. There's too much
debate on what the
best tools are There's
too much debate on
the best models. This
is all a journey.
New things are coming
out all the time.
It's about focusing on
the primitives that you
the primitives that you
can tweak and tune.
One of the most
important compositions is of
course the agent and
then its underlying primitives,
12 leverage points of
agent Agentic, specifically the
core four context model
prompt tools. You can
now control all of
it better than ever.
This codebase is
gonna help you get
started by the way.
Hop in here, use
any one of these,
push them up against
their limits, break them,
right? These aren't perfect.
These are meant to
show you you can
use agents to solve
your domain specific This
is our inspect agent
and we have find
and we have find
logs for users. Let's
go ahead and run
that, right? So find
logs for user and
let's just find all
these since it caused
the error. I want
to see all these
logs about this user,
summary only. So our
agent is going to
think about that and
process that for us,
right? There's that tool.
We should get a
response message out of
this because this is
our process row. There
we go. High severity,
low severity. So you
can imagine, you know,
this is a great
tool to use to
trace before an error
happened in your workflow.
Very importantly, you can
Very importantly, you can
just call whatever tools
you need to right
from your domain specific
UI and your application.
Okay, so very powerful
stuff here. I think
you get the point.
This is how you
can deploy custom agents.
We can then notify
our support team, notify
our engineering team and
stack this up to
do whatever we need
it to do. You
can see the options,
same kind of format,
allowed tools, disallowed tools,
system prompt. This is
a complete custom agent.
For Zoom, there's a
model. Here's our custom
MCP server. We are
building specialized agents. Now
let's talk about when
let's talk about when
you should use this,
all right? Because you
don't always need custom
agents to do this
work. In fact, you
saw that in our
microagent application, right? We
extended the existing capabilities
right out of Cloud
Code via the Cloud
Code SDK. So when
should you build a
custom agent? You build
custom agents when you
need one of these
things. If you need
programmatic agents, if you
need to solve repeat
workflows with agents, if
you need to solve
domain-specific problems, better than
domain-specific problems, better than
anyone with compute. If
you want to keep
your costs down while
keeping performance up, remember
every prompt costs and
whatever's in that context
window on startup is
going to cost you.
That goes all the
way down to the
system prompt and the
user prompt. And then
if you need permission
checks, custom agents allow
you to prevent your
compute from destroying your
work or causing issues,
right? They also make
it easier if you're
deploying these agents for
someone else, for someone
in your team, for
your engineering org, PM
support. Custom agents allow
you to make your
agents safe, right? You
can set up hook
You can use different
You can use different
elements of your clock
code options to make
sure your agent doesn't
cause issues, okay? But
most importantly, you know,
a big idea we
talk about in TAC
You build custom agents
when you want to
stay out of the
loop. These are the
high level reasons why
you should build a
custom agent. Now, that
doesn't mean that you
always should. It is
natural that if you're
pushing compute to its
limits, you will end
up at custom agents.
But for a lot
of use cases, out
of the box agents
are good enough. So
if you're operating in
the loop, like many
the loop, like many
of us are with
our agents, right? You
just boot up a
Claude Code agent, prompting
back and forth, getting
work done. There's no
reason to build a
custom agent to do
this unless you have
some grandiose idea on
how to build a
better agentic coding tool
than some of the
best engineers doing this
24 seven. Okay, you
can extend this a
little bit, make it
your own. You might
like to build your
own UI wrapper around
this, whatever. Also, I
don't wanna violate any
terms of service at
all. In no way
do I think you
should try to compete
with Claude Code. I
think that's actually a
massive mistake. They own
massive mistake. They own
Agentic Coding. They are
the best at this.
And despite efforts from
some of the other
Gen AI companies, I
don't see that changing
anytime soon. and I
use all those tools
and I've been using
Claude Code since the
beginning, okay? So don't
try to reproduce your
own engineering agent. Cloud
Code is that, okay?
And this space is
just, Totally, totally oversaturated.
So when you're operating
in the loop, prompting
back and forth, use
Claude Code. Use the
out-of-the-box agent. When else
should you use out-of-the-box
agents? When your workflow
agents? When your workflow
is generic enough that
the Claude Code SDK
can deliver on the
work you want done.
You also want to
use out-of-the-box agents. If
you're just exploring your
prototyping, there's no innovation
needed here. You don't
need custom agents to
explore and prototype. If
you need a balanced
generalist engineering agent that
works well in 80%
of situations, use the
out-of-the-box Claude Code agent.
When your tasks are
short-lived, lightweight, They don't
require repeatability and they're
not domain specific. It
doesn't matter what agent
you use. Okay. You
don't need a custom
agent for this. You
agent for this. You
know, there's an important
idea here to echo
and you saw it
inside of the plan,
build, review and ship
agents, right? Our SDL
micro agent workflow here.
That is a multi-agent
system. We just redeployed
a lot of the
baked in Claude Code
tools and functionality. We
only appended the system
prompt, right? So we
are just extending cloud
code and this is
a good delineation. There
are extension agents. or
extended agents, and then
there are complete custom
agents. This is really
defined when you overwrite
the system prompt and
then defined even further
then defined even further
when you start using
your own custom tools,
right? For our UltraStream
agent, this was not
the Claude Code product
at all, right? We're
using the Claude Code
SDK harness, absolutely. That's
where a lot of
the value is in
agents. It's in the
agent loop, it's in
prompt caching, it's in
a lot of the
niceties that they provide
out of the box,
but we did not
use Claude Code at
all, right? our SDLC
micro agents here, they
did. This is software
work. That's what Cloud
Code is for. So
don't step on these
boundaries too much. If
you're working on engineering
work, you probably just
need to fine tune
need to fine tune
just a little bit,
hide a couple of
tools, do a couple
of tweaks. Our plan
agent, it only needed
to write the spec.
That's it. Everything else
was reading tools. You
get the idea, all
right? The big idea
here is I wanna
communicate to you that
you don't need custom
agents. I think if
you're pushing all the
way to the edge
of agentic engineering, you
will end up building
custom agents. it's better
agents then it's more
agents and then it's
custom agents but i
will say and i
want to make this
super clear you can
just extend agents right
build extended agents use
build extended agents use
the out-of-the-box agents as
much as you can
and then only when
you need to build
your complete custom agent
with unique prompts models
hooks tools permissions so
on and so forth
tailored to your domain
specific use case that
being said as you
scale up as you
become more capable As
you become an agentic
engineer that focuses on
building systems, that builds
systems, right, as you
compose the outer layer,
the new agentic layer
of your codebase,
you will want custom
agents to perform better
agents to perform better
than any out of
the box agent can,
okay? So both of
those things can be
true. You wanna use
the right tool for
the job. We're just
doing the same thing
over with new technology.
We're using the best
tool for the job
at hand. The agent
is compute scaled. You
want to know how
to deploy this across
your tools, products, services
for yourself, for your
engineering work and for
your users and customers
and the Claude Code
SDK and other agent
SDKs that will arise,
right? OpenAI has their
own agent SDK. These
own agent SDK. These
are all powerful toolkits
you can use to
control the core for
within your agents to
scale them intelligently. If
you're doing one size
fits all work, use
the out of the
box agent. Don't think
super hard about this.
Just deploy compute to
get the job done.
But as your work
becomes more specialized, as
you deploy agents across
all aspects of your
engineering, you first want
better agents, more agents,
and then custom agents.
So one of the
benefits rolled into the
agentic horizon extended lesson
agentic horizon extended lesson
is that you get
to vote on upcoming
lessons. Upon launch, going
to have three additional
slots for you to
vote on ideas for
the next upcoming lesson.
As you exit this
page, you can click
into that and you'll
have several options to
select from that detail
the next agentic coding
topics you want a
deep dive on. Maybe
you want more concrete
examples of the agentic
layer, or maybe you
want to see more
custom agents, or you
want more context engineering
techniques, or maybe you
want to see an
agentic deep planner, right?
There are tons of
There are tons of
ideas. Whatever you want
to see next, place
your vote. After about
500 to 1,000 votes,
I'm going to take
these, I'm going to
tally it, and I'm
going to build a
lesson, a hyper-focused lesson
on the topic you
and other engineers decide.
Obviously here, we're focused
on the bleeding edge
use case of agents.
core four, the key
ideas embedded in TAC.
If this works out
well, I'll do more
vote-based lessons. So place
your vote there and
you'll guide the future
of the agentic horizon.
This codebase is
gonna be available to
gonna be available to
you. Every agent you
saw here is gonna
be in the apps
directory waiting for you
to dig in and
understand how you can
build out custom agents
from zero in a
simple script all the
way up to complex
multi-agent user interfaces that
help you control your
compute and use custom
agents in a better,
more powerful way. This
is a codebase
you're going to want
to ultra think about
and understand how you
can extend and use
the ideas we've discussed
here. Deploying effective compute
and deploying effective agents
and deploying effective agents
is all about finding
the constraints in your
personal workflow and in
your products. Think about
repeat workflows that can
benefit from an agent
inside of a script,
a data stream, an
interactive terminal, all the
way up to user
interfaces that can tackle
high return on investment
problems in your tools
for your team and
for your business. Agented
coding is not so
much about what we
can do anymore. It's
about what we can
teach our agents to
do. This is how
we push our compute
to its useful limits.
to its useful limits.
Follow this path to
unlock massive value for
your tools and products.
Better agents, more agents,
and then custom agents.
I'll see you in
the next Agentic Horizon
extended lesson.
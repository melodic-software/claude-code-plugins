# Lesson 3: Success is Planned - The 80-20 of Agentic Coding
# Video Transcript (46:32)
# Source: https://agenticengineer.com/tactical-agentic-coding/course/success-is-planned

lesson three of Tactical agentic coding. What was once a complete joke is now the most valuable skill any engineer can have. The prompt is everything. Why is that? It's because it's the medium in which you communicate to your you communicate to your agentic tools and all generative AI technology. At the heart of everything we're doing in TAC is learning how to properly communicate to our agents to get the work autonomously. Adopting your agent's perspective is no different than empathizing with a friend or a coworker. In order to understand them, connect with them, and solve problems, you must take their perspective. With AI coding and the big three, and the big three, context, model, and prompt, you are able to push language models hard and generate hundreds and thousands of lines of code. But AI coding is not enough. Coding is just one element of engineering. There's a reason they're called Vibe Coders, not Vibe Engineers. They're just coding. We're doing it all. This is real engineering. Agentic Coding and the Core 4 takes it all to the next level with the addition of tools, our prompts, have tools, our prompts, have become exponentially more powerful. Prompting is how we enable this. In order to maximize this ability, we need to scale our prompts. Here's a simple question for you. What does a scaled prompt look like? You guessed it. It's a plan. It's a specification. It's a PRD. Plans are prompts scaled up for high impact the plan is the prompt and that means great planning is great prompting full circle great prompting full circle great prompting is all about communicating to gen ai and planning is how we do this better than the rest in lesson three we're going to scale your prompts into plans and scale your plans into something even more powerful to drive a massive impact we'll do this by using a new game breaking tactic. Once you see this tactic and the implementations of it, it will be impossible to unsee. You'll understand how a few engineers are changing the engineering game changing the engineering game because you'll be one of them. What we do in this lesson will unlock your ability to not just augment, but automate the entire software development lifecycle with your agents shipping work on your behalf. Those who plan the future tend to create it success is planned in this lesson we enter the plan and build phase of the agentic software developer life cycle with just three tactics you'll learn the pareto you'll learn the pareto 80 20 of agentic engineering first you stopped coding our hands and our minds are no longer the best tool for the job then you adopt your agent's perspective so you can maximize the leverage you get from your agents. Then you can template your engineering. This enables you to deliver consistent results across hundreds of agent executions, no matter the size or complexity of your codebase. That's right. What we do here contains one do here contains one of many solutions to the my codebase is too big problem. When you template your engineering, You encode your problem solving into reusable units that you, your team, and your agents can see, use, and importantly, improve. Plans are the end result of templates. It's how we implement this tactic on a functional level. But planning alone is expensive. It's time consuming, and there's always something to miss. And the time planning consumes scales with planning consumes scales with the difficulty of the problem you're aiming to solve. And of course, the size and complexity of your codebase. There's always something to miss. So how can we take our plans to the next level and encode problem solving into reusable units so we don't burn our precious engineering time planning? We need a solution that works on small to large codebases that can run on a variety of work, including chores, bugs, small features, large features, new codebases, all the codebases, all the way up to massive refactors. We do this by taking our successful plans and converting them into templates, one of the 12 leverage points of agentic coding. In this lesson, we differentiate what you can do by building a suite of templates that give you full control over how your agent solves a variety of problems. Agentic coding tools like Codex, Copilot, Devon, Jules, Gemini CLI, and whatever comes next, these tools comes next, these tools are great, but they're limited by nature. No matter how great AI gets, they don't understand your codebase like you do. And out of the box, they don't let you control your agents to the granularity you need to to ship code end to end throughout the software development lifecycle. So how can templates let us encode our engineering and hand off massive amounts of work to our agents through plans? Let's break it down in the TAC3 code base. Let's go ahead base. Let's go ahead and open up the terminal. And let's clone in the lesson three repository link available in your loot box below. I'll CDN and I'll open up VS code here. Here we have our natural language code base with our changes from lesson two. I'll boot up Claude Code and fire slash install to have our agent set up our code base. Important note here, we're executing a new script in the install command. Let's go ahead and open this up. If we look at install.md, you can see we have a new we have a new line that's going to run here. So we're going to run the scripts copy.m and this is going to copy our dot m file from our tack to codebase. This is just a quick way to reuse resources. If you open up scripts, you can see exactly what that's doing there. Here we're having an agent with a reusable prompt do this work for us. Agentically. These reusable prompts, much like templates we'll explore here in this lesson are extremely powerful time savers due to how reusable they are and not just for you, but for your entire team. So there we go. If we close everything If we close everything here, go to app server, you can see our dot environment variable file was automatically copied in or agent set everything up our back in dependencies, front of dependencies and everything is completed and we had it report its work. Now let's open up a new terminal here and we'll run our start script once again. So I'll say scripts start and let's just go ahead and boot up our natural language SQL application. If we open up the browser, you can see our natural language SQL interface. Let's hit upload data Let's hit upload data and select our user data here. Show users with age between 20 and 40. We'll fire that off. As before, our natural language query application is working as expected. Ages 20 through 40. If we open up the terminal here, we can see that standard out is getting written. And if we wanted to, we could boot up a cloud code instance and have it read in all of the output of our servers so that it can make changes for us. Great. Now let's run our first template and understand the template and understand the impact it has on your agentic coding abilities. So let's open up a brand new cloud code instance here, and we're going to trigger a template called slash chore and inside of this template it accepts a parameter so i'll type replace all server print statements proper python logging log levels make sure all output is written to standard out all right let's fire this off here we're running a special custom slash command that produces slash command that produces a unique outcome this is a template and a meta prompt what is a meta prompt It's a prompt that builds a prompt. More specifically, this agentic prompt builds a plan based on a template that our agent fills out. Let's monitor the results here and we'll break down the contents of this unique agentic prompt. You can see our agent is looking through our codebase. It's also using its reasoning model. And so it's searching through the code base, it's gathering context for this tour. It's looking through our server, looking through our server, it's thinking through these changes. Let's go ahead and full screen the terminal. And now it's going to create a comprehensive plan to replace all print statements with proper Python logging, just as we asked, right? If we hit up here, we can see that exact prompt that we ran. We kicked off a reusable prompt and then we passed in just one string. We're writing a high level prompt, which is a prompt that's void of detail. Fantastic. Now we have a new plan that details exactly how to convert all of our print statements with proper Python logging. with proper Python logging. Let's go ahead and open that plan up. All plans are written to the specs directory. And so we can open this up and we see we have a brand new file. If we open this, and we go into preview mode here, we can see we have a chore written out top to bottom. All right, the chore of course, replace server print statements. There's the description. And here are all the relevant files to solve and complete this work, server and main. Now we have step-by-step tasks in our plan. We then have step four, run validation commands. four, run validation commands. And you can see here, we have a header that describes what we're gonna run to validate that the work done was successful. All right, and then we have a final notes section. So this is the generated plan. Okay, so we just ran a prompt that created a plan for us. It turned our one sentence prompt into an entire plan. Okay, so let's understand how this happened, right? Let's open up dot Claude commands. You can see we have a whole slew of reusable prompts. Let's click into chore and understand what this prompt understand what this prompt does. If we go into preview mode here, you can see we have a prompt chore planning. And so every great prompt contains a purpose right at the top. Here we have a reusable prompt that looks ordinary, but the instructions in this prompt completely changes your engineering impact. So we're asking our agent to create a new plan in the specs directory to resolve the chore using the specified plan format, follow the instructions to create the plan, use the relevant files to focus on the right focus on the right files. So you can see here as headers, we have our detailed instructions, We have relevant files to help guide our agent to success. We then have our plan format. Something super important to note here, we're asking our agent to create a new plan. What is a plan? It's just a prompt, right? It's a large prompt. So this is this tour file here. This is a meta prompt, right? It's a prompt that generates a prompt. This is extremely powerful. Not only should we stop coding, we should also lean into and leverage our into and leverage our agent to write plans with us and for us. Now we can take that idea a step further. Let me go back into preview mode here. We can see the plan format. Okay. So we requested this agent creates a new plan in the specified markdown format. We are giving our agent a template. Okay. So you can see here, there's the plan format. We have the chore at the top, chore description, relevant files, step-by-step tasks, validation, and then notes. And of course this lines up with exactly what was generated. exactly what was generated. If we go ahead and collapse here, we can see this exactly, right? This was our plan that was generated from our chore template meta prompt. Okay. Why is this so interesting? Why is it so powerful? It's because we can now template our engineering. If we keep scrolling here, you can see our last section is just chore with the claw code argument parameter that just takes whatever we passed in right here, takes our string and places it down here as the chore. And this is the section that we reference in our purpose. reference in our purpose. So this is super powerful. I hope you can see where this can go. This is a massive, massive idea, but we're not done yet, right? We only generated a plan. Okay. It's just an auxiliary document. Let's go ahead and implement the work detailed in our replace print with logging plan. So let's go ahead and open a new terminal and boot up another claw code instance. This might seem like a weird pattern, but it's ultra important. We'll discuss why later. Let's run another simple slash command to kick off this plan. We're going this plan. We're going to run slash implement. and then we're going to get the file path to the plan we created. So I'm just going to copy that and paste it here and that's it. We're going to fire this off. It doesn't take a lot to do a lot, but you need the right information. Our agent is getting to work here. Let's go ahead and crack open the implement prompt to understand what's going on. So we have another reusable prompt here, implement and check this out, right? Very simple, very concise, 12 lines of natural language. We have the purpose at the top, follow the instructions to implement the instructions to implement the plan, then report the completed work. All right. So here we have instructions, just a single instruction. Read the plan. Think hard. We're activating Claude Codes information dense keyword to activate the reasoning model. We're using one of the 12 leverage points of Agentic Coding by turning on the reasoning model. Let's go ahead and go into Yolo mode. You can see the changes flowing in here. We'll accept all think hard about the plan and implement the plan. All right. And then very interestingly here, you can see as an can see as an argument we're passing in the plan. This is a higher order prompt, AKA a hop. Okay. There are a lot of advanced concepts here. We'll circle back to the higher order prompt in a moment. But basically what we need to know here is that thanks to this prompt, if we hit up here, implement and then we pass in the plan that we want implemented, This is going to pass our file path here. And then our instructions, of course, said read, think hard and then execute. Okay. And so this is going to run the replace print with logging plan. And let's logging plan. And let's go ahead and decollaps this. This is super powerful. We have plans getting passed into plans. You can see our agent is working through the steps. You know, you'll notice something very powerful here. We're tapping into our agents capabilities. You can line up the to do list that was created here with our step-by-step breakdown. Okay, so we're leveraging our plan. We're aligning it with the capabilities of our agent. We are betting big on Claude Code as the best Agentic Coding tool, but this will change over time, right? We over time, right? We want to focus on tactics. We want to focus on capabilities. We want to focus on what the tools can do for us. Of course, we're using cloud code. We're big fans. But the key here is the capabilities that are unlocked by the tool. Okay. And then very importantly, if we go back to the implement, you can see we have this report block right under our plan summarized work and then report files change. And you can see this happening exactly. And this is going to be super, super important once we really start getting into true off device agentic coding. Okay. device agentic coding. Okay. What we're doing right now is just the beginning. It's just the bedrock to really, really scale or impact templates are critically important for this. Look at all the work we just did. Look at how reusable this is. This is fantastic. We can see there's the report, there's the files changed all the work that our agent just did. If we hop back over to our plan, we can scroll to the validation commands and we're embedding another lever of agentic coding. We have several self validating loops with tests. All right. So not only right. So not only did it run all of our PI tests to prevent regressions, it also ran server and main just to make sure that it works. All right. So there's all the files changed. If we want to, we can of course, open up a terminal and run get diff ourself and we can see everything that's changed. All right. Looks great. It looks very precise. It looks like exactly what we asked for, right? This chore has been completed agentically with two prompts, one for the planning phase and one for the coding building phase. Okay. We can, of course, test this if we want this if we want to. I am very, very confident that this is working, but you know, it's always good to manually test. So we can go ahead, kick off our server again, open up the browser, do a refresh, And so we can see that info log right there. That looks great. Let's go ahead and run that same query. So let's get users ID name sorted by signup date descending. So there we go. We got that sorted by signup date descending. And if we go back, we can see that we have our success query processed in that new logging format with the logs exactly with the logs exactly as we asked. And we can of course open up the server.py file, to manually validate this, we are going to standard out. There's the basic logging. We can do a all file reference and we can see it's in main and server. Fantastic. So this chore was completed. We now have no print statements inside of our codebase, right? Here's a search all no prints. It's all logging or logger, right? Let me turn on regex and there we go. So fantastic. Let me close all this. Now the question is how far can is how far can we push this? And the answer is very, very far. Okay. Let's look at some more comprehensive templates to agentically complete bugs in the same way. All right. We can scale this up to solving bugs, features, and really anything you can encode into your prompt, right? These are repeatable solutions for success. Okay. We're literally encoding our engineering. We're templating our engineering into the codebase. Okay. This tactic, It's critical. Let's knock out a bug in this code base. I'm going to close everything here. Let's open the terminal just open the terminal just like before. And once we kick this off, I'll fully explain why I keep opening new terminals and new cloud code instances. So we'll boot up Claude Code again and then we'll type, guess what? Slash bug. Okay. And you saw it inside of our commands. We have slash bug. And so let's solve a bug, right? So we're going to write a high level prompt that directs our agent toward the goal we want accomplished. Guess what's in? This .bug markdown file, you guessed it, it's a meta prompt that takes a template to generate a plan. This pattern, a plan. This pattern, these concepts are ultra, ultra powerful. We are templating our engineering. I hope you can see where this is going. Chores, bugs, features, front end, back end, Research notebooks, data analytics, code optimization, net new code bases, all of it. Experiments, literally all of it. I mean, all of it can be templated. Don't limit yourself. Don't make the mistake in thinking that Gen AI can't solve your problem in a major way. If for some reason you're right, and there's a very small probability of that, trust me, you will be me, you will be wrong, okay? Tools will change. Models will improve. All right. We know this for a fact. Let's smash this bug. So slash bug and then end quotes here for our argument. You know, we still have that exact same format, right? So we have bug down here at the bottom of the file. And then we have, of course, our template right above that. And we can go into preview mode, right? So we have our bug. We have our plan format, relevant files and instructions. Okay. And of course at the top we have our purpose. So this is our bug smashing template, fully reusable. It's gonna fully reusable. It's gonna create a plan that we can then iterate on and fire off. Resolve major issue, our SQL statements not being escaped, user input into SQL. That's it. We've just described the problem at a high level. We've templated our engineering into how we solve bugs. And now our agent is going to create this plan for us. All right, so there it is. Of course, we enabled thinking mode. We always wanna throw more compute at the problem, right? Especially as we start to scale this up. Just scale this up. Just to kind of go over these key ideas again, we're putting to work several leverage points of agentic coding. We're generating plans that's getting created by templates, right? Reusable units of our engineering practices, right? We're teaching our agents how we want the work done, right? We're giving our agent our perspective and in turn, we know what our agent's perspective is. We are enabling thinking mode, right? If you just search for think, You'll be able to find this. This is an information dense keyword that Anthropic has encoded into this has encoded into this word here. Think. And so you can see the model thinking. We, of course, have a core four at work. None of this works without the core four are in agent leverage points. And we, of course, have a well-designed codebase. It's a simple structure, right? Client server. It's very easy for agent to understand where everything is located. We're not doing anything tricky or fancy or unusual here. Pretty straightforward codebases, right? And then we have a little bit of documentation in the readme detailing our structure, how to set things up, so on and so forth. And so we can And so we can see here our spec has been created. We can go ahead and check out how our agent has decided to solve this bug given our encoded best practices for solving bugs like this. Okay, so we can look at this fix SQL injection vulnerability and we can see a great breakdown of how to smash this bug. Okay. So same deal. You can see exactly what's going on here. We have a couple of different sections for our bugs. You know, you can see we have the problem statement and the solution statement. We have steps statement. We have steps to reproduce, right? So full on engineering steps to reproduce. You start and then you pass in something malicious or send in a natural language query, and then it'll actually get executed. Okay. So classic stuff there. Don't focus too much on the code here. Obviously example code base. We're just using this as a framework to learn great agentic coding and agentic engineering. We have a root calls analysis. And then we have, of course, our relevant files inside of our template. We asked our agent to, if you need to create a new file, right? So if I type new file here, I asked list the new files in a new H3, a new header called new file. So that's exactly what happened here. We have a new SQL security file that can be generated. And then of course we have step by step tasks. Okay. And you can see here, this is a non templated portion. If we just copy important, We can scroll down here and see, you know, step by step execute every step in order top to bottom. Okay. Super important. All right. And then there it is. So top to bottom, all of our tasks, we of course have our validation. We're leveraging tests and We're leveraging tests and then we have notes. Okay. So same idea, right? We're encoding our engineering into templates. Okay. Then our agent runs it as a meta prompt, a prompt that generates a prompt. It generates a plan that we can now, execute. Okay. And then once again, I promise I'll explain this right now. So, um, why do I keep doing this? Let me just get this fired off. So slash implement and then same deal, right? I'll copy the path to our brand new prompt file. And then I've been working, my plans aren't committing any changes. So I'm going to go ahead and actually go ahead and actually commit these solutions, right? Commit my specs and the code changes into the codebase. I have a quick command for that. I'm going to go ahead and commit that and then kick this off. And we'll talk about how to use Git in these systems. TLDR there is you want each one of these steps to commit their changes. More details on that in upcoming lessons. Our agent is going to solve this for us now, right? Same deal. There's all the steps. It's read the plan. It knows that it's running the implement. So it's going to run in, right? In thinking mode with the reasoning mode. And then it's mode. And then it's going to write a great report for us. So let me explain. Why do I keep opening up new cloud code instances? You know, look at all these terminals. I keep opening new terminals and starting fresh agent instances that have no memory of what just happened. Why am I doing that? Don't we want to keep rolling the important context between planning, building, and really the entire software development lifecycle? No. And there are three important reasons we don't want agents stretched across the software development lifecycle. By running fresh agents By running fresh agents over and over, we do a few things. We free up our context. Focus every available token on the task at hand this is important for large code bases and for long running tasks when we use one agent for one task we allow it to focus its context window on one mission this should sound familiar for any engineer that's been overloaded right we as humans we also have context windows we can only do so much and the more we focus the better the result okay better the result okay so that's the first reason next we force our prompts plans and templates to be isolated, reusable, and improvable assets with zero dependencies. Okay? By having this expectation that we're going to run fresh instances, Right. We now have a pattern where we encode templates to solve problems repeatedly in the way that our specific code base and problem and application needs. And when we generate the plans, we can do the exact same thing. Right. We know what our agent is going to run. We know what our agent is going to execute. OK, this is super important. We have a trail of success or a trail of things we can improve. Right. When you start writing this template, you're probably going to miss something. You're probably going to need to add more detail somewhere. you're gonna need to tweak it, and then maybe you'll run into a bug where, super important here, maybe you'll run into a bug where you need a more specific template to address, maybe you have a specific weird system on your front end or a class of bugs, then you can bugs, then you can specialize your bug, right? And this is a huge, huge solution for big codebases. The more code, the more complexity in your code base, the more you'll want to dial in your reusable templates to solve specific problems really well, okay? And there are a bunch of tricks we can layer on here. There are parallel agents. You can delegate a lot of work. You can use isolated sub agent context windows. There's a lot of fancy tricks to handling large codebases. And so let's refocus on the last point. Number one, we free up our context window. up our context window. We let our agent focus. Number two, we force our prompts, plans, and templates to be isolated, reusable, improvable assets with zero dependencies. Okay. And then lastly, most importantly, when we use fresh agents, right? When we use brand new agents every single time like this, right? When we just open up brand new instances over and over, we prepare for true off device agentic coding. Remember, we're not here to babysit a single agent. We a single agent. We want to improve our KPIs. Okay. We want to increase the size of work we can hand off. We want to decrease our attempts. We want to increase our streak and we want to decrease our presence KPI to zero. All right. That means we need to at the right node of the software development lifecycle, kick off new instances with no previous context. Okay. Said another way, we need to decouple our performance from the conversational context window. And by conversational, I mean by conversational, I mean more than one prompt, right? We want one shot successes. And that doesn't mean that our agents do a ton of work, right? That's the whole point, right? Size goes up, but it does mean that our plans are prompts scaled up contains everything an agent needs to get started. And you can really pack your plans in. Okay, right here, I have a relatively small 100 line plan that is going to, you know, you can see all the files is modifying. See all the work that's happening right here relatively happening right here relatively small you can really scale up the size of both your template and then the plan that gets generated from your template right so this is why we use fresh agents over and over and over by running fresh agents on meta prompting templates and planning assets we can understand what went wrong by knowing exactly what was in the context window when i boot up this agent right when i when i set this up i know 100% I know what the agent's perspective is. We fired off the implement markdown off the implement markdown file, which passed in our plan. So it read this file and then it read this file and then it went to work. Okay. So we have a very, very good idea of the exact context, right? The perspective of our agent when we started. All right. So ultimately the reason for this booting up new agents over and over and over, we want to move toward true, off-device Agentic coding. If you do this right, it will completely differentiate your engineering from the rest. So we can rest. So we can see our agent is still working here, 13.3K tokens running on whatever the best model is. So you're operating in the future, whatever your best model is, use that. Make sure you activate thinking mode to throw more compute at the problem. You want your agent operating at its highest efficiency mode so you can hand off the most work possible. You want to be leveraging your agent to its maximum capability. And so there's something important to mention here. You know, we can continue to scale the template and we can continue to scale what you want to run inside of your higher inside of your higher order prompts. We have a whole set of reusable instructions. Our implement can run any spec that we generate and it'll actually get the work done. Many, many, many different modes we can run our implement plan in. For instance, you could write a new higher order implement prompt that read your plan, implemented it, and then it can have a set of instructions saying, you know, after you implement, review the work completed against the plan. Okay. You can ask a lot of ask a lot of higher order activity on the work that you're doing. This is the great part, right? Because just like in some programming languages where we pass functions into functions, we have higher order prompts. And so that means that the implement prompt here can do different things and shape the work and shape the repeatable success that you can template into your codebase that you can systematize into your codebase. And so you can see here, Our agent is on the testing step. It's creating that test SQL injection step. We SQL injection step. We have another test coming up there, manual test script. That all looks good. This is a really big idea. We're going to be working with different types of prompts, meta prompts, templates, and higher order prompts where we're passing in prompts into prompts to leverage and generate outcomes. Okay. We have a new primitive to work with here, right? We have a gentic prompts thanks to the core four where we can execute arbitrary tools, our agent, Claude Code, with the powerful models it has is smart enough to know how to do a lot of work over a long work over a long period of time. As you can see here with this looks like our task just got completed. This new task was implemented. We got tests. We got read me updates just like we asked everything is here. And of course we have that final report step. It's running that get diff and check this out. It's checking its own work right self validation. It has two issues it needs to fix here. It's going to fix them automatically right. This is the power. Of templating your engineering. I still haven't lifted a finger. I have stopped coding. I barely did anything with the plan, right? So this is right? So this is really powerful. I built these tactics for you to be in a very specific configuration so that you can think about these tactics every single day on the ground as you're engineering, right? This is Tactical agentic coding. Think about these every single day you're engineering boots on the ground. Stop coding, take your agent's perspective, and now template your engineering. All right. If you do this right, it will change everything. This is a massive differentiator. Having agents run loose on your code base without structure, without base without structure, without knowing how you do things is a plan for failure. It will not scale into the true agentic engineering future and to the true agentic engineers we are aiming to become. As you progress through each lesson here, You'll become an engineer they can't replace. Okay. So this is one agent isolated right here. It's going to keep solving problems over and over. This idea of refreshing your agent every single time you want to run is super, super important, right? This enables true off-device Agentic Coding. Let off-device Agentic Coding. Let me just show you one more example of that. Our bug is still getting smashed here. We're going to let this run. And then of course we'll validate the work at the end. We're moving toward Automating the full software development lifecycle. So how will we build features end to end? Do we, the engineer, sit down and type code? We know that that's not the case, right? We're going to stop coding. We don't even want to type the plan ourselves. Can leverage agentics to look through our codebase to help us plan and then we can of course you know review the plans review our templates that generate the plan so how are plan so how are we going to do this end to end we won't be able to open up the terminal we need a key feature that we've discussed that really differentiates agentic coding so we want to build features end to end we need a feature that lets us run our agents without us being there and in order to do that that means we need to be able to run our agent right in the terminal because we can access the terminal anywhere right local environments cloud environments so on and so forth there's going to be a big hot topic in our next lesson I just want to show you the beginning of this right here so I'm going to open up a new file up a new file and I'm going to start writing out our prompt so here we have yet another template where we have encoded our engineering best practices in to the template, right? We're using this syntax here to have the agent update specific parts of the template to create the plan, right? And this is all based on the instructions. You know, you have full access to this codebase, take these, make them your own, make a couple of tweaks and just get one running. You wanna get to that first aha moment as fast as possible. Let's turn our attention back to our blank files. We're gonna run slash We're gonna run slash feature. I'm going to kick this off. I want to show you where this is all going. We're starting to scale up our compositions of agentic coding so that we can run across the entire software development lifecycle. That's why this is so important. We need to be able to run this autonomously. We need to be able to run this without our presence. This is why it's called the presence KPI. We want to create a new query history side panel in the app. All completed queries store in the database names for each query. names for each query. in the side panel. When we click, we refocus the main panel button next to, what was this called? Upload data. Great. So now we have this. And if we hop into the terminal, we can see our previous agent has completed all the work. So it's implemented this. We have 52 tests, right? 18 new SQL injection prevention tests. And we can of course refresh our server here and just validate that this code works. All right. So we can type something random, users can cat email. right? So we're just right? So we're just kind of typing whatever. And there we go. So we're can catting name and email all of our SQL injection code looks like it was successful, hide, upload data, open up products. And we're just doing some testing here, right? We want to understand that our fixed SQL injection vulnerabilities task did the job. And so this is why it's important to have steps to reproduce inside of the plan. Now we can just come in, look at the work that was supposed to be done and validated ourselves as well, right? We can also scroll down to the validation commands that our agent was running. And we was running. And we can of course also go into the server, we can CD into app server, Then we can, of course, ourselves just run UV run pie test. All right, there it is. So we know that all this is working. We have this brand new test SQL injection file. We can look through it and validate all the work that was done. This is great. We're not gonna do that here. It's not a good use of our time here, but we can see, you know, even through some manual testing and validation, we have our concat working. We have all of our tests running. Our agent is properly comprehensively building plans from our templates. It's acknowledging our templates. It's acknowledging and running the self validation steps to close the loop. This is a big idea. Huge, huge leverage point of Agentic Coding. We're going to talk about it has its own dedicated lesson because this idea is so important that you can see here. We're just doing that here. Update documentation, conference of tests, It's all here. It's all in the plan. It's all easily reproducible. If we wanted to tweak the plan, we could. If we wanted to tweak the higher order prompt, if we wanted to tweak the template that generates the plan, we totally could. But it's all here for us, all here for us, right? So let me show you one more thing here. This encapsulates everything we've done here and showcases it to what's coming next. So we have this feature, right, slash feature. We of course write our prompt and slash feature is another template. That's also a meta prompt, write a prompt that creates a prompt. We have the structure here specifically built out for creating new features, right? Net new features. This is very differentiated from, you know, generating bugs or chores, right? These are not the same are not the same types of engineering work. So you want to differentiate each one of these. We're going to run that, but we're not going to run it inside of a manual instance. Right? We want this to run on its own in a box on some device somewhere else. Okay. So what we're going to do is open up a terminal and we're going to replicate that by firing this off using claw code in its programmatic form. All right. Here's what we're going to do. We're going to take this prompt and we're going to wrap it here. I'm going to say claw dash P and then we're going to wrap this in to wrap this in quotes. We're going to escape these quotes here and then new line. We're going to run this in the terminal. So we need something like this. And for brevity, I'm just going to paste this in and you can see exactly what's happening here, right? We're running this in programmatic mode, right? Output format stream running in dangerously skip permissions. This is going to work just fine for now. It's very low risk. We're setting our model. We want verbose and then check this out. We're going to write the output. We're going to stream the output into this file. Let's copy this. Go Let's copy this. Go to the terminal. Fire it off. Okay. This line is where things are all going. I know this looks weird. I know it might feel uncomfortable. We don't see our agent. We don't know what it's doing, but as we scale up, as we improve our plan writing, as we learn the template, our engineering, as we know our agent's perspective, this is what we want to do right across the entire software development life cycle. This prompt here represents the planning phase. We can of course embed more prompts into the planning phase, more agents into the planning phase, into the planning phase, but we can do that of across the software development lifecycle to turn it into the agentic software development lifecycle so that our agents are operating this for us. So we are streaming this output. So if we open up the sidebar here, you can see we have a new JSONL file. Let's click that and check this out. Our agent is actively working right now and we're getting the result reported. All right. So this is this is live, right? If I swap files here, you can see that this is slowly getting appended. All right. So this is line 22. Now we're at line 23, 24, at line 23, 24, right? So this is really powerful. Our agent is running, right? This slash feature, right? And we know that if we open this up dot cloud commands feature, it's doing this, right? It is generating a plan, right? You can always read the purpose right at the top of the prompt, generate a new plan in specs.md to implement feature using the specified plan format, follow the instructions to create the plan. use the relevant files, right? And then we're breaking it down. Whatever detail this templated piece of your engineering needs, you come in here, you write it out, you fill it out. You'll find that you'll need some sections while other sections aren't that important. All right. But that's up to you. This is where a lot of your key essential engineering time and resources will be spent. You want to be building the system. That builds the system, right? This is what we're doing when we template our engineering. Okay. So we see this is still running. This is a feature. So it's going to be a lot more work. Check this out. Look at how much work our agent is doing in the background, right? I'm not, we're not aware of this, right? You of this, right? You can imagine this command is running on any machine anywhere, right? It was kicked off in some way, somehow, and this is doing engineering work is going to generate a plan for us. And you can imagine we can chain these agents together. We can check, their output, we can do a lot with this. All right, we're just building up the fundamentals. We're getting to this intermediate zone where we can really ship a ton of value autonomously by doing the work Right. Prompting back and forth inside of a terminal, right? Back and forth and back and forth and back and forth. and back and forth. This is just scratching the surface. This is barely valuable compared to what we'll be able to do when we scale up one agent, two agents, five agents, 10 agents across the software development lifecycle. All right. Plans are critically important. Plans are prompts scaled. Great planning is great prompting. When you save your plans into your codebase, you create artifacts that you, your team and your agents can reference. You can also think your plans as staging environments for code that will be generated, right? It's be generated, right? It's the code, it's the engineering work compressed into natural language that your agent will expand. So that's why plans are so important. Now, why are templates so important? As we've discussed, templates let you encode your engineering practices into your codebase for, again, you, your team, and most importantly, your agents. Writing plans take time. And they're error prone, right? We as humans, we are error prone. That's okay. There's a new best tool for the job. We can not only stop coding, but we can reduce our writing and our planning and our direct planning and our direct planning by templating our engineering to let our agents write the first and sometimes final draft of our plans, as you saw here in this codebase. And if we look over, this agent is still planning. This is a entire feature. It takes a lot more work. So it's running really high class compute. Check this out. And it's running in reasoning mode. We, of course, activated reasoning mode, and it is planning this work for us. If we open up our spec, we can see we have query history panel, right? Our agent just right? Our agent just wrote the first draft of this plan for us and maybe the final draft, okay? This is why templates are so important. We can see the agent is done. Now imagine this happens in the cloud where agentically all you do is pass in the high level work that you want done. And sometimes, you know, the high level prompt isn't enough for a feature, right? For something larger. You might want more detail here, right? That's totally cool, right? This is where human in the loop planning your work is still ultra important. Templating lets you move faster, and let your agent do the hard work of the hard work of looking through your code base, figuring out what needs to go where, and you can template all of that. Another great reason to use templates, another reason why templates are so important, you can, of course, improve them. As you scale up your work and increase your size KPI, your feature prompts will likely get bigger or they'll get more precise, and that's great. You'll be able to solve more problems in a better, more accurate way over and over and over, right? We get this self-improving loop inside of your code base for your agents, all right? And then last but not least, why are templates so important? button, you get to encode custom templates, to encode custom templates, right? These can be anything chore bug feature. These are just high level generic units, generic classes of engineering work. But you can really dial this in. If you want to, you can say this is the front end feature for these sets of pages, right? Or these sub pages on my front end. Or you can say, here's a chore template for our database migration system. Or here's a bug resolver for our research notebook, you know, system, whatever, whatever it is, right? whatever it is, right? You can really dial in and create custom templates for everything. And truly the more custom your templates are, the more unique your engineering gets. And that means your work, your code base, your products is likely more differentiated, but those are the reasons, right? So templating, is ultra, ultra powerful. All right, so you can see our agent finished. We can scroll down to this new spec, query history panel and check this out, super comprehensive. Let's open this up in preview mode. So we have a very comprehensive brand new feature plan, query history side panel, great description, side panel, great description, user story, problem solution statement, relevant files. Check this out. We have encoded the planning phase for creating features for our codebase. It's all here. We can now pass this off to the code step in the software development lifecycle and have an agent implement this, right? Implementation plan, foundation, core, integration, steps, right? So here it is. We're templating our success. Bam, bam, bam. Look at all these great steps. Top to bottom, final polish, testing, integration, edge polish, testing, integration, edge cases, acceptance, validation, super important. Our agent will do all this work. This is critical. I'm not gonna run this right now. There is a lot of value here. In the TAC3 codebase. Do not wait. If you haven't been following along, this is your call to action. Take your time to just run one of these. All right. I want to get you to a great aha moment with templating your engineering. Open up a chore. Copy this right into your code base. You know, use this codebase if you want, whatever you want to do. Run one of these. All right. Run slash chore and just do something and just do something small. Don't wait to complete this course. You'll miss out on getting ahead now. All right. This lesson will get you to your first aha moment. Don't make the mistake of thinking that this is not going to work for your system, for your codebase. Maybe you think your codebase is too large, yada, yada, yada. Be very careful thinking that these tactics can't work for you. And on your codebase that that is a limiting belief. Okay. Models will improve tools will change. These tactics are ultra ultra useful. I could not have created Tactical Agent Agentic Coding without all of Agentic Coding without all of these and the upcoming tactics, which will take this to the, to the next, next level. Okay. We're building on top of the tactics we're building on top of principles of AI coding. We're putting it all together and we are automating our work And we are learning to use agents. We're becoming agentic engineers. We build the system that builds the system. I hope you can see how templating, how higher order prompts and how meta prompting and planning is a key, key aspect of becoming an agentic engineer. So what's agentic engineer. So what's next in our next lesson in lesson four. We lean into programmatic agents. We lean in to true off-device Agentic coding. In order to do this, we need to learn how to trigger our agents and let them run in their own environments. We'll do this by tapping into the highest composition level and the greatest leverage point of agentic coding, AI developer workflows. Once you start to understand all the ways your agent can operate alongside you and how to improve them, not to improve them, not if, but when things go wrong, right? This is engineering. Things will go wrong. But in the next lessons, you'll be equipped with the tools to get back on track and then template your engineering so that future agents stay on track. This lesson puts you three steps closer toward becoming an engineer they can't replace. Great work here. Take a moment, review some of the resources available to you in your loot box below, dial in, to this key tactic of agentic coding, template your engineering. This is how you scale is how you scale your agents into your codebase and solve your domain specific problems. Okay. There's no hand waving here. I guess, I guess there's a lot of hand waving, but you get the point, right? These tactics are key ideas you can think of every single day you're engineering, right? Stop coding. Think from your agent's perspective, template your engineering. All right. There is work to be done here in creating and building up great templates. But if you do this right, it will change everything. I'll see you in lesson four where we'll learn to let your product ship itself.

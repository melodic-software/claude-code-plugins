The prompt is now the fundamental unit of engineering. And with agents, every prompt you create becomes a force multiplier. One well-crafted prompt can generate tens and hundreds of hours of productive work. One bad prompt compounds failure at the same rate. So how do you consistently create

do you consistently create prompts that deliver two, five, 10, 100X returns on your time investment? The answer starts with a senior engineering mindset shift. You have to ask yourself, who am I creating these prompts for? It's not just for you. It's not just for your team. We're now engineering for three audiences, you, your team, your agents. This is the stakeholder trifecta for the age of agents. This is the agentic shift that most engineers haven't yet made.

engineers haven't yet made. The winners here are building libraries of reusable battle-tested agentic prompts with composable sections that work like lego blocks. You can swap these in and swap them out when and if you need them to scale your engineering impact with compute. You saw this hands-on inside of TAC. Every prompt we built had a similar structure, some with certain sections, some without them. By writing these prompts consistently, we were able to communicate with ourselves, with

communicate with ourselves, with our future self, our team, and of course, our agents. Most importantly, your agents. And once you write these prompts, once they become reusable, you get to a level where you know what the prompt will do given a certain input. And this accelerates you along the path of moving from inside the loop, outside the loop, all the way up to ZTE, a critical concept we discuss in TAC. This is the North Star of agentic coding. You want to be handing off more work to compute

more work to compute and setting up systems that trigger your workflow so your presence isn't needed. You want to be building AFK agents. And this all comes back to the skill that was once mocked as a joke, prompt engineering. But things have changed. We're now agentic prompt engineering. And every prompt you write, every line that goes into your prompt has the ability to call Tens and hundreds of tool calls and run from minutes to hours. This makes a gigantic prompt engineering one of the

engineering one of the most important skills for engineers to focus and master. And of course, that's what we're talking about today, right here, right now. We're going to understand the seven most powerful agentic prompt formats and most importantly, the exact sections that make them up. We're talking about the most useful sections for your prompts and how challenging they are to operate, how much skill you need to operate, not just the prompts themselves, but the individual sections, title, metadata, workflow, relevant

title, metadata, workflow, relevant files, codebase structure. And we have our list of prompts that we're going to work through. The prompt is everything. Context engineering is incredibly important, but we can't forget about the underlying skill that dictates everything, the prompt, and now the agentic prompt. What we're doing here is learning how to best communicate what we want to the trifecta, you, your team, and your agents. Let's level up our agentic prompt engineering abilities by mastering

engineering abilities by mastering the prompts and their composable sections. So at the first level, we have the high level prompt. It's the reusable ad hoc static prompt. This is the one off that you throw into a file as soon as you start repeating work that you know that your agent can do without a problem. It contains up to three and no less than one section. Title. high level prompt and purpose. We have prompt examples here we're

prompt examples here we're gonna work through as we progress through each level of our agentic prompt formats. Let's start with all tools. So inside the agentic prompt engineering codebase, we have the simple list all tools prompt and it does exactly what you think it does. We're asking our agent to look at their system prompt and list all of their tools. This has just two sections, title and the high level prompt. And we can of course kick open a new Claude Code instance run all tab and kick this off. There's a typical classic prompt. It helps you understand what

helps you understand what your agent can see. By the way, you can run this in any chat interface, any agent to understand what they can do. We have a title and a high level prompt. These prompts are going to stack up on each other, but let's go ahead and just place our first two sections. We have the title. How useful is this and how much skill do you need to operate the title section of your agentic prompts? Not much and not very, right? So, I'm gonna throw the title down here in the C tier for usefulness and D tier for skill requirement. We also have the high

also have the high level prompt. Now this is gonna be more useful and very easy to write. There's not much going on here, right? Just type a high level void of detail description of what you want your agent to do and hope that they do it. So let's scale this up a little bit more with the start prompt. So again, we have a very similar structure, but here you can see we have a little bit more detail. So we have our title, we have the purpose, and then we have our high level prompt that's starting to move into mid-level territory, right? We have some details here. We have the CD command. We have bun install, bun dev. So there's

bun dev. So there's more detail here, but this is still a simple, high level prompt with the one addition of the purpose. We have one line where we're saying, hey, this is exactly what you're meant to do. Notice the tone of voice here. We're speaking to our agent, right? Start the agentic prompt tier list application for development. This is the purpose of this agent when we run this. Okay. And so purpose is powerful and it's simple to use. This is going to be B tier useful and it's going to be D tier skill requirement right it's quite simple to write a purpose just

write a purpose just say what you're trying to do as you can see here the high level prompt is very simple this is a great place to start it's a terrible place to end whenever you start doing repeat work hand it off to your agent right three times marks a pattern copy whatever you're doing and just write it as a high level prompt and then move up the levels from there all right so in terms of usefulness and difficulty We're gonna go ahead and grade the high level prompt in the exact same tier list here. So you can get decent value out of the high level prompt without putting in much effort, right? This doesn't require any skill. Just

require any skill. Just type and ask for what you want. Now, the next prompt format we're gonna look at is exponentially more powerful. Let me show you exactly why. Now we reach level two and level two is a huge milestone. The next prompt we're gonna look at is the workflow prompt. This prompt represents a sequential workflow with a bunch of new additional sections that you can work with. Out of all the agentic prompt formats we'll look at, this is easily the most important one. Why is that? It's

Why is that? It's because of this workflow section. Let's go ahead and grade the workflow section and the workflow prompt just to set the stage to showcase how powerful and how useful this is. So workflow and throw it into the S usefulness. This is the most useful section and we're going to throw it in C tier difficulty. It's actually not that challenging. to use the workflow as you'll see in a second. We're also gonna take the workflow prompt and place it in A tier usefulness and C tier skill requirement. So these are both very useful,

are both very useful, very powerful. And so why is this so powerful? Let's look at one of the most basic versions of this in the prime command. So this is something you've likely seen me use. The prime command sets up your agent to gain an understanding of the codebase so it can start working. As you can see here, you can build many prime commands to do and operate on different sections of your codebase. We dig deeper into why you should use a prime command over classic memory files and our elite context engineering lesson. Check that out if you haven't. But here we have several sections to break down. So

to break down. So we have this brand new metadata section and this is specifically metadata for Claude Code. But other agents and tools you work with will have their own version of this. But here we just have a simple description. We have our same title. We have our purpose here. And below we have two new sections, right? We have the workflow and we have the report. The workflow section is exactly as you think. The key here is that it's a sequential list of tasks that you want your agent to execute to get the job done. So whenever we run our prime command, we want our agent to

want our agent to do just this, right? We can of course spin up an agent to run this whenever we want to. It's gonna do just these two things, right? And we're setting it up in the purpose, execute the workflow and report sections to understand the codebase and summarize your understanding. So let's go ahead and grade the metadata and the report section. So metadata is important, but it doesn't actually do a whole lot for your prompt, for your team, and for your agent. It's not completely useless, but out of all the sections and out of all the prompts we'll look at, metadata belongs in C tier

belongs in C tier usefulness and C tier skill requirement. Metadata lets you do a couple powerful things. You'll see in upcoming prompts like specify the exact tools or the exact models that you want, but other than that, it's not all that valuable. And we also have the report section. Now the report section is gonna be quite a bit more valuable. The report section lets you change the way your agent responds to you. Anything from running strictly in JSON output, YAML output, or to report in a specific structure or to include specific information in the report,

information in the report, it all goes under the report section, right? This is your output section. This is your format section, okay? And to be super clear, you can call these sections whatever you want. I'm using the most consistent, the most information dense keywords to represent every section, okay? Out of the tens of thousands of prompts I've seen and used and run these sections, keep coming back over and over and over. So no matter what you call them, they're still going to be there as you scale up the level and the capability of your agentic prompts. You can see

prompts. You can see here, this is the foundation for the workflow prompt. All right, we're now executing a series of steps that can get very complex that can call many, many tools. All right, so let's look at another prompt, right? We have this build prompt. Let's check this out. And you can see here a little bit more metadata, right? Our build prompt is only able to use read, write and bash tools. And it has an argument hint. The argument of course leads to a really important section, a super underappreciated section, the variables. Okay. And so, you know, before we get to variables, everything

get to variables, everything else is the same. right? We have the title, we have the purpose. In our purpose here, we're being a bit more prescriptive about what to do exactly. And then we have our workflow and our report section. Variables is very, very important, right? This is where your prompts become massively more valuable. A lot of the work we do is repeat work that runs in step sequences of steps, right? This is what the agentic workflows right now are solving for us. And you can throw agentic workflows right into one of these workflow prompts, right? You can also

right? You can also scale them up with ADWs as you've seen and as we've discussed at length and tack, but the variable section is ultra important because now we're parsing the claw code arguments syntax here and in our prompt, when this gets executed, this is going to update so that whatever the value is here, right? Right. So path to plan and then check this out. We are referencing the name of our variable throughout our prompt, okay? Variables let you pass information into your prompts. Here we're building up our own easy to understand natural language variable

understand natural language variable syntax that we can reference throughout the prompt, okay? And powerful modern language models running in these agents. They're powerful enough to know exactly what you mean when you keep referencing it, especially in this syntax, right? This consistent syntax. Not only is this great for your agent, it is of course great for you and your team. Look at how easy this is to understand, right? We have a variable coming in and this is the path to the plan, okay? So very powerful stuff here. This is a dynamic variable in contrast to a

in contrast to a static variable. Let's go ahead and grade this, right? How powerful are variables? How useful are they? These of course are very useful this is gonna be a tier usefulness and we're gonna put this in B tier difficulty right B tier skill requirement because now we're referencing variables both static and dynamic across your prompt okay and you can see here this is just a simple 23 line prompt this is gonna scale up in difficulty right let's go ahead and look at a bigger prompt Let's look at quick plan. So when I'm working with prompts, I like

with prompts, I like to just always open it up in full and then collapse to the second level so that you can see all of the sections consistently. You can quickly see the composable sections in this prompt. OK, this immediately gives you a good idea of how complex and how powerful the prompt is. So you can see here we have more metadata. We have the model now argument, hint, description and allowed tools title. And then we have our purpose. And so notice the language here, right? Create a detailed implementation plan based on the users requirements. We're just like very directly talking to our

directly talking to our agent. All right. And so by contrast, by having this very kind of dry, direct language, you and any engineer on your team can come to this prompt and collapse everything and just read this upper section to understand exactly what this does, right? And what the capabilities are. Then you can just dial in one piece at a time, right? So what are the variables here? You can see here we have that user prompt coming in as the argument and we have the plan output directory. Now this is different, right? You can see how different this is. This is a static variable. This is a variable we're placing right

variable we're placing right in the prompt that doesn't change. You can't pass anything in to overwrite this. This is a powerful static variable versus a the user prompt. a dynamic variable, right? That changes as you pass in work. This prompt is going to write to the specs directory, right? And if you want to, you can change this to be anything you want. So say you like PRDs, right? This will write to the PRD directory, right? All you have to do is update this, save it, and that's it, right? You don't have to keep referencing this everywhere. And of course, We can copy this and do a search

and do a search on this variable, right? And throughout, you can see this getting referenced. Notice how much time I'm saving by having just a single static variable here that we can reference throughout the prompt. And also notice how easy it is to understand this. Great prompting is great communicating, okay? So what we're doing here is quickly communicating to ourselves, to our future selves, to our team, and of course, to our agent, okay? So user prompt's gonna come in, is gonna output to the specs directory, right? And very quickly, just two sections, you know exactly

sections, you know exactly what this is gonna do. We do have a new instruction section here. Let's think through this, right? How is this different than the workflow section in your agentic prompts? So the workflow is the step-by-step play of exactly what you want your agent to do. Oftentimes, your agent if it's a Claude Code level agent, it's gonna come through and create a list, a concrete list inside of its to-dos, inside of its plan of your workflow. So this maps very, very well to modern agentic coding tools. As specified below, you can see here we're creating a specific

we're creating a specific output type. We're almost bleeding into the examples section, but this is just a report, okay? So we're just specifying the output format we want. So the workflow is a play-by-play step of what we want done. And then the instructions are surrounding information on the individual steps in the workflow. So this is a great place to just come in and add auxiliary information on how your workflow should work. Now, to be clear, oftentimes you can just combine these. Right, and you can create nested bullet

can create nested bullet points underneath your workflow steps. In upcoming prompts, you're gonna see that exactly. But you can use instructions to just quickly tag on useful information to aid your workflow, okay? So we have one new additional section here, right? We have the instructions section. So how does this rank? This is gonna be right below the report. Right, so probably as useful and as challenging to use is the report section, right? This is a bullet list of additional information that aids the workflow, okay? So it's not ultra difficult to use,

ultra difficult to use, but oftentimes you don't need the instructions. You can just use a workflow. All right, but I wanted to call this out. These are two distinct patterns. And especially when we start talking about system prompts versus user prompts, you're going to see that the instructions are going to be a lot more valuable for your system prompt versus your workflow. When you're writing these reusable agentic prompts, this of course is going to be a lot more useful for the actual play by play that you want your agent to run in a repeat fashion. We have the prime tier list. Okay. And I just want to show this off. We have one additional section

have one additional section here and we have no metadata. So notice this format, right? Title purpose. And then we have code-based structure This is a distinct section. We have our workflow and you can see our workflow is getting a little bit more complex here. We'll break that down in a second. And we have our report. Okay, so just a kind of super simple blank report. Let's go ahead and talk about the code base structure. What is this new section? Another way to think about the codebase structure section that you can swap in and out of your agentic prompts. This is really a context map, right? This is the real name

is the real name of the codebase structure. But normally this is just, you know, as we're engineers working in codebases, This is usually just called codebase structure, okay? And the distinction here is that you're not saying, right, you're not telling your agent to read these files. You're giving them a quick map of where the files are, what the structure looks like of the relevant code, right? We have a prime tier list here. So we're priming against a specific part of our application and we're specifying exactly what every file does, you know, at a hundred foot view.

a hundred foot view. There's our previous prime command that ran. We can of course clear that out and then prime the tier list and now the tier list is going to run not these files, but in our workflow, we've specified exactly what files we want to read. Okay, read these files exclusively. We have to be a little bit stronger with our language here. We have an information dense keyword important that has more value to our agents and to the models that run them. And so you can see here, we're only reading these specific files, but our agent now has in its context window, thanks to our prompt

thanks to our prompt engineering, it has a map of how to quickly find relevant files. Okay, so instead of having to search this manually, run additional tools, chew up additional tokens, it has a quick simple map. Okay. And again, codebase structure, you and your team can quickly look at this and understand it. Let's go ahead and rank this one. This is not as useful because of course agents can do this. The big benefit here is that it's faster, right? This speeds your agent up. It helps your agent understand more quickly. So we're going to throw this right under

throw this right under metadata, right? Code base structure is about C tier usefulness and it's not that challenging to use. We're just giving a codebase structure. and we're asking for a little bit of detail, all right? But now the important interesting thing here is our workflow. If we look at our workflow via regex, we have a more built out list. And so your workflow can be as detailed as you need it to be. So as we cycle through this, You know, you can see here we still have our numbered list, but underneath this we're adding additional details, right? We even have a list with a list underneath. Okay. And so

underneath. Okay. And so this is very common. You know, you've seen, you've likely seen prompts like this where the workflow step has decent amount of information underneath the steps. The point is to keep these clear and concise. We could probably clean up this section a little bit and maybe turn it into an instruction set, but this is fine. Right. And then at the end here, we run what our original start prompt does at the end of this prompt, right? we boot up the application and solve dependencies, kick it off, open the browser. Okay? So you can see here, we're scaling up the value. We're scaling up the use we can get

use we can get out of our prompts by using these consistent and swappable prompt structures. The workflow prompt is very, very powerful. All the prompts stack up on each other and the workflow prompt is an absolute pillar for all subsequent prompt levels. It's important to note here, by the way, that every one of these prompts, if you open up build, every one of these prompts has a kind of consistent structure, right? It has the inputs, it has the workflow and it has the output, input, workflow, output. This is a very consistent

is a very consistent three-step pattern you can use to think about how to design and build your prompts, right? Inputs, we have the actual work that your agent does, and then we have the report. Now, obviously, all of this information is important for your agent, but the input and the output are specifically useful for you and your team. Now we can quickly know what's coming in and what's going out, right? Of course, we'll be spending a lot of time on the workflow, dialing this in, making it do exactly what you want, but this is a useful framework for thinking about how to build great reusable agentic prompts

great reusable agentic prompts consistently, input, workflow, output. Let's move on to level three of our agentic prompt format. At the next level, we continue building off our existing sections. Let's open up build.md. You know, this prompt is going to come up over and over. It's a very powerful, very simple prompt, but you can see there's something going on here on line 17. We have flow control, okay? So level three is the control flow So we're building up on our workflow section and we're adding this new capability. Remember,

this new capability. Remember, every prompt is about the capability that it offers you. Every prompt format is about the capability that it offers you and your agent. The control flow prompt lets us run conditions, loops, and early returns. You can see here if no path to plan is provided, immediately stop and ask the user to provide it. So we can, of course, very quickly test this. You can see here our prime tier list finished. It's got a great, great detailed layout for us on this specific feature. Check out our extended lesson

out our extended lesson on context engineering to understand how context priming can be more valuable than using a memory file. But anyway, let's go ahead and clear this out. Right. And let's just kick off build. And we pass in no path to our plan. Right. Our variable isn't there. So right away, our agent sees this and it stops. Right. This is the equivalent of an early return asking for feedback, right? We need some information, we cannot proceed unless we have a path to plan. This is of course the most simple version of flow control inside of your prompts. You can imagine this getting

can imagine this getting a lot more complex. The most popular extension of this will be of course conditionals and loops. Let's open up the create image prompt here. We're creating an image. We're going to run that exact same understanding workflow, right? We collapse everything on level two and we just analyze the prompt top to bottom, right? We have the metadata section. We have the title. We have a kind of a bad tone of voice purpose, but it's fine. This will get through. We're saying this command generates images. Really you want that direct tone of voice. You'd say something like this, generate images based

this, generate images based on the provided prompt using replicate MCP server. We're talking to our agent. We have a request targeted toward our agent. All right, you can see here two variables. Let's open up our variables and you can see here we're using a new syntax. And we also have a bunch of static variables with a couple of bullet points. Okay, so let's analyze this, right? So we have word plus colon, and this gives us our variable format. So what's going on here, right? We have several variables and we're using Cloud Code's positional argument for our first arg and then our second argument. Right. So of course

Right. So of course this would look like this slash create image. And you can see here we would pass in something like some file with image prompts and then we pass in a number positional arguments. You know exactly how that works. We have three additional static variables. Okay. So very powerful stuff here. We're starting to use more static variables that we can reference throughout our prompt. Right. This is very useful for agents and to communicate value to yourself right in the future and to your team, right? So image output directory, we

image output directory, we can quickly just see where this is referenced and we can see, you know, the model we're using, we can quickly just update the model that we're using to generate the image. And of course we can update the aspect ratio, so on and so forth, right? All this stuff. We can add arbitrary static and dynamic variables here, right? But the interesting thing here is in the workflow, in these control flow prompts, you can of course, with natural language, request loops. Okay, so we're saying important, then generate number of images, right? We're referencing a variable using the image generation prompt following

image generation prompt following the image loop below. So we have this XML block to add additional structure. We're communicating to our agent when the image loop starts and stops. We're also, of course, communicating to our team where the loop is. We're operating in natural language. We want consistent patterns throughout our prompts for the trifecta, right? And so just more workflow details, right? Top to bottom, use this tool, pass an argument, aspect ratio, wait for completion. And then throughout we're referencing our variable. So you can see here, this is getting more and more complex, right? We're

more complex, right? We're doing more and more with our prompts. Of course, have the report generates images at scale for us in a loop. Let's go ahead and rank this. When it comes down to it, you know, the conditional flow prompt I would say is about as powerful, probably a little bit more powerful, more useful than the workflow prompt, right? There's probably a little bit above this. It is gonna be more challenging though. It requires more skill to think through and analyze the workflow step in your prompt to understand the control flow that your prompt

flow that your prompt is working through, all right? So for that reason, we're gonna place this in A tier usefulness and B tier skill requirement. Let's crack open the edit image and you can see a very similar format, you know, nothing to change here, right? We have a consistent process, right? We have meditate at the top title, purpose, variables, workflow, and notice here, no report section. Remember every one of these sections is swappable. Use them only if you need it. If you don't care about the output format of your prompt, right? Remember the three-step workflow, input, workflow, output. If

input, workflow, output. If you don't care about your output or if you don't need variables coming in, don't add the section. Okay, this is the key to writing great prompts. Only add what you need, right? These are composable pieces of your agentic prompts. Okay, so the edit image has no output format. And so you can see a same deal here. If we open everything up, we have variables and we have a workflow and our workflow has a loop embedded inside of it. All right, and we also have a stop command here, right? A couple conditionals, you know, if the token is not available, exit immediately. If the base64 command isn't available,

base64 command isn't available, exit immediately, right? This prompt does a specific thing in a specific workflow very well with a loop embedded. All right, that's the control flow prompt. Now we continue to scale up what we can do with our agents while properly communicating to the trifecta. Let's go to level four. So at level four, we have the delegation prompt, right? The delegate prompt. This is a prompt that kicks off other agents to do work. Notice how distinct every one

how distinct every one of these prompts are. They give you a new advantage, right? A new capability. Key section here, if you're gonna be delegating, you're going to want variables that you can pass into your sub-agents, okay? So that's the only section tweak that you might make. Let's go ahead and open up parallel sub-agents. Once again, you know, same process, collapse. Check out the format. There's our metadata. title purpose. You know this workflow should feel repetitive and that's what you want right. You don't want it to be novel every time you open up a prompt that consumes your engineering cycles that consumes your ability to work through

ability to work through more engineering work and to generate value where you want to be thinking less about the stuff that can be solved with consistency. Consistency is the greatest weapon against confusion for both you and your agent. This is a key idea in both our extended elite context engineering lesson and in this lesson. We're clearly communicating. We want to reduce confusion to the very minimum. You want to be thinking as you're writing these prompts, you want to be thinking, if I handed this to a coworker, could they complete this work

they complete this work top to bottom? If that's true, you've probably written a high quality prompt. And imagine you hand them 10 additional prompts. don't change the prompt format every single time. This is why this consistency is so important. All right. So if you open up variables here in our parallel sub agents, you can see we have two positional dynamic variables, prompt request and count. Right. And you can quickly understand this prompt by reading the purpose, right. File workflow, launch count in parallel to accomplish tasks detailed in prompt requests. All right. And then in the workflow, step-by-step play nested

workflow, step-by-step play nested bullet points nothing fancy very consistent you can see just referencing variables throughout but so what is the key advantage of this type of agentic prompt format. We are handing off work to compute. We're having our agent fire off agents. So there are many ways to use this. If you've already taken the elite context management extended lesson, you already know that there are only two ways to context engineer, R and D. And here we're using the D of that framework, right?

of that framework, right? So we can kick this off, right? If we just clear this agent out slash parallel, and I'm just going to paste in a prompt that I have here, right? I'm going to paste this in, extract information. We want to add to our claw.md that we want all future agents to know about essentials only present bullet list do not modify the file directly and we want three let's say let's kick it up to five this is the advantage of spinning up more compute, right? You just bump up the number of instances, the number of agents you want to fire off to accomplish a task. And so what's the advantage of running a prompt like this, right? LLMs, agents, they're non-deterministic.

LLMs, agents, they're non-deterministic. So when you ask multiple agents to do something, they're going to return with different results, okay? And you can see here, we're firing up five agents focused on a different aspect of the codebase. So our primary agent is instructing the sub agents, right? Our primary agent is the prompt engineer for our sub agents. And this is where things get really tricky, right? This, you know, agent delegation is very powerful, but it's hard to use. Let's go ahead and grade this right now. So we have the delegate prompt and I'm gonna

prompt and I'm gonna go ahead and throw this into S tier usefulness while being in A tier skill difficulty. Okay. This is an advanced technique. Why is that? It's because we're managing multiple instances of agents and we're writing prompts that write prompts, right? We are specifically saying, right, we're talking to our primary agent. In step two of our workflow, we're saying design agent prompts, create detailed self-contained prompts for each agent. Include specific instructions, define clear output expectations, okay? We're really

expectations, okay? We're really kind of building out that input workflow output three-step structure for our primary agent to pass into all of our sub-agents. This prompt is very powerful. We're spinning up more compute that in itself can build out, you know, entire prompts and agents. So this is a very powerful concept. This is the future of engineering. Once you build up great agents that perform for you and get work done, the next question is how many agents can you spin up? How much work can you do? How much compute can you use? Right? And of course, that's what TAC

course, that's what TAC is all about. That was a big, big theme inside of TAC, spinning up these pipelines of agents that operate with and without us via Outloop systems, big idea, all this prompt engineering, all this agentic prompt engineering is just about tapping into that better than anyone. So for that reason, this is S tier, ultra useful, ultra valuable, very hard to use though, right? You need to be conscious about the flow of information between your agents. So that's just one way to use this, right? You can see we're getting that response flowing back

that response flowing back in here. We can kick up another agent here and let's go ahead and run our load AI docs. Let's go ahead and open that up, load AI docs. So once again, with great agentic prompt engineering, we're just gonna collapse everything, understand things one step at a time, right? Metadata, title, purpose, input, workflow, output, okay? Every single time, consistency beats complexity, consistency makes you faster. Okay, it makes your team faster and it makes your agents faster when you find the working formula. And guess what?

formula. And guess what? I'm handing you the working formula right now with these prompt formats. All right, so you can see here variables. We just have one static variable for this load AI docs delegation prompt. We are going to delete old docs after 24 hours and our AI docs here, we have documentation for agents. And if we open that up, Our agent has just deleted them. It's just deleted all these and now it's going to reload them because they were older than 24 hours. You can see here, same deal. We're going to loop where we have a explicit, a new on the fly information dense keyword that

information dense keyword that we can reference throughout our prompts. We have a loop and we're actually having our agent call a sub agent directly. And so you can see this, we have five doc scraper agents scraping the documentation and writing it to a new file. We should see some of these come in here by now. Yep, there's our documentation coming in. inside of our AI docs. All right. So our agents are bringing those in one by one. We are delegating. We're offloading. Of course, once again, this is the D and the R and D framework of great elite context engineering. So this is ultra powerful. And then we have a simple

we have a simple but specific report format. And you're going to see our primary agent return in this exact report format. Okay. We have one more prompt here, the background prompt. And you know, notice how every previous level stacks up, right? You can Pull in whatever levels you need and to the highest level again that you need to solve the problem. Here we're delegating agents. We're using control flow. We have conditional statements. You can see here several ifs in our workflow. And of course, this is running in the most powerful section

the most powerful section of all your prompts, the workflow. So this is great. You can see our agent returning in that exact format. We had AI docs report right here, success or failure URL, markdown path, there it is. So we have massive control over this agent, right? We knew exactly what was gonna happen when we kicked off this prompt, okay? And this is the key for transitioning to out loop agentic code and you need to know what your prompts are gonna do. And the best way to know is to be consistent and of course to test and to prove out your agentic prompts,

out your agentic prompts, right? One more here, we have the background prompt. Once again, I hope you're getting annoyed and kind of bored of this workflow, but this is how you write great prompts at scale over and over and over for you, your team and your agents. You stay consistent, okay? Metadata, title, purpose, right? We're using that direct language run a Claude Code instance in the background to perform tasks autonomously while you continue working. Okay, purpose clearly defined one or two sentences variables here you can see we

you can see we have three dynamic variables and you know where this is going. We covered this in our elite context engineering. I'm not going to run this but if we open up the instructions we have some you know auxiliary important information for the workflow. Okay. And the workflow is of course the step-by-step play. This one gets really complex because we start detailing exactly how to kick off a brand new agent via the CLI. And we're actually updating the system prompt in a very massive way here. We'll talk about system prompts versus user prompts in a moment, but you can see here, this agent is going to

agent is going to kick off another primary agent in the background. And this agent is going to continue to report to a report file as it works in the background using whatever model we specify. All right. This is the delegation prompt, right? The delegate prompt. You can have your agent pass off work to other agents. Okay? Let's move up the stack again. Let's add more power to every one of our prompts. Let's move up to level five. Level five is interesting. It's a concept we discuss in tech

we discuss in tech and use quite a bit. This is the perfect prompt for running agentic workflows where there's some dynamic elements that you want to change while having the kind of top level infrastructure of your prompt, the higher order prompt, you want that to stay the same. So what are examples of that? We can, of course, open up build. Okay. So once again, we're back at the build prompt and, you know, classic format, right? There's nothing new here. Metadata, title, purpose, variables, workflow, report, input, work output. Okay. So what's going

Okay. So what's going on here, paths of the plan. The big key with the build prompt with these higher order prompts is that we are passing in prompts into prompts. Okay. This is a distinguishing capability of your prompts. This allows your prompts to scaffold top level information while you pass in work, right? Or plans in this case, right? We're passing in plans that we build directly in as a variable. Okay. And so you know what this looks like. We don't need to go over this, but we could do, you know, slash build and then pass a path to a plan, right? Which is going to be in

going to be in specs, slash something, something, something.md. And this comes right out of your quick plan or your equivalent chore builder, feature builder, or your even more specific specialized plans for specific sections of your codebase, your experts, right? Very powerful. In terms of where this places on our tier list, these are harder to use and you can embed all this logic into the individual prompts themselves, all right? We'll put this in B tier use and maybe this belongs in A, but I'm gonna put this in

gonna put this in B tier for useful and ATF or difficulty. This is very powerful if you know what you're doing. The most obvious higher order prompt you can create is the one that just builds the work into your codebase based on the plan, all right? So this is the higher order prompt, providing a consistent structure so your lower level prompt can be changed and updated and operated on, all right? Let's move on to level six. At level six, we have the template Meta Prompt. Now, this

Meta Prompt. Now, this is a prompt used to create another prompt in a specific format. Levels one through let's say four will be 80 or 90% of all of your prompts, right? And your code bases doing real engineering work, getting things done for you. When you get up to level five, six and seven, you really get into that meta territory where your prompts are building prompts and your prompts are improving your other prompts, all right? We'll get to that in level seven. The template meta prompt is very important. As you saw in TAC, template meta prompts are an essential concept for templating your engineering, okay? This is

engineering, okay? This is a big, crucial idea. We go at links discussing in TAC, okay? Why is that? It's because in your templates, you can teach your agents how to build like you and your team builds. You know, we have team at a prompt workflow. Let's just look at this. There's a powerful prompt that builds a prompt, but you'll notice exact Same format with a couple of changes here with a couple pieces that are important, all right? Metadata, title, purpose, variables, where we're passing in that high level prompt, that becomes the

prompt, that becomes the prompt we want to generate. And then of course we have that key workflow section. Okay. You can imagine exactly what this does. Create a new prompt. Look at this XYZ. Prefer this. We're basically teaching our agent how to build prompts. Okay. So this is a prompt that builds a prompt, but we have a couple of sections here. Now we're going to clarify exactly what these sections are. Remember we had that codebase structure also known as a context map. We also have that here with the name documentation. We're explicitly calling this documentation documentation, but this

documentation documentation, but this is a context map. Okay. It's just clear to call this documentation right here. So that's what we're doing. All right. And then we of course have our specified format. So this is, this is very important. This is the template. Okay. So intersections, right? This is, we actually are missing that here. This is our template. Okay. And this is key. This section gives your agent running this agentic prompt, the exact formula the exact output structure that you wanna generate. Now, it doesn't just do that. We talk about this

We talk about this at length in TAC, but it also allows the agent to fill in the blanks of the specified structure. So you can see here, right, we have a prompt that builds out our level two workflow prompt, variables, workflow, report, and based on the high level prompt, we're going to follow the instructions to create a new prompt in the specified format, right? And here, this should be follow the workflow to create a new prompt in a specified format. All right. And before you start web fetch everything in documentation, right? So basically look at

So basically look at the context map, pull that stuff in and then operate, right? So very powerful template meta prompt, to build out workflows. Okay. So this is the, you know, let's just be super clear about this. This is the most powerful prompt you can write. It's the prompt that creates your other prompts. Okay. Now again, this is going to be very hard to use, right? Because not only are you writing a prompt, you're running a prompt that writes your prompts. But once you start codifying these structures and once you start getting your prompt formats very consistent, I highly

very consistent, I highly recommend you build out the prompt that generates your prompts. This increases your agenda engineering velocity by quite a bit right the prompt don't forget how we started this the prompt is the fundamental unit of engineering so engineers creating more and better prompts at scale are the winners here level six It's at level six for a reason, right? This is the template meta prompt. You have to really dig deep here and think through what your agent is going to see and do throughout this prompt.

do throughout this prompt. But this is a powerful one. I'm giving this to you here in this codebase to spark your imagination and to help you build out your next meta prompt, okay? We can look at one more here. We have plan, byte view, and this one's really interesting. We're creating a plan for building a net new view three application with TypeScript MVP from scratch. So this is a rapid prototyping prompt. And of course, same old, we're not doing anything new or different here. We come to the prompt, we collapse and we understand. So you can see this prompt has many of

prompt has many of the formats we've discussed, right? Including this code base structure, right? Because we want to let our agent know exactly what things are, where they should go, right? What the structure looks like. This prompt would absolutely run without the section, but it can help in small ways by speeding things up. You can see we have that template section, right? The plan format, we're detailing exactly how we want the plan to look like. And then of course at the bottom, we have a report and we're just saying, give me just the path to the plan you just created. A very powerful

created. A very powerful prompt. You can see here, we're stacking up and swapping in a lot of our sections, right? So this is the, template section. So again, very powerful, very hard to use really this belongs right underneath the template meta prompt as it should write this is hard to do, but it gives you a lot right this will pay you back massive dividends for every prompt you write that you can have your agent create for you, all right? We start delegating to other agents and we start looping our agents back onto themselves, so to speak, all right? That's the template meta prompt, very, very powerful prompt

very, very powerful prompt structure. Let's move on to the final level and then let's talk about system prompts versus user prompts because we've been primarily looking at user prompts. So at our final level, we have the self-improving prompt. Inside of Claude Command's experts directory, we have a new agent experts pattern that we detail in our context engineering lesson. Check that out if you haven't. But the idea here is quite simple. Inside this prompt here, we can just crack this open for a second and

for a second and collapse. We have this expertise section, right? And this section is powerful. We're not going to dive into exactly what this does, but it gives this agent, it gives this expert specific details that we're going to have another agent or this agent itself update. So we went from meta prompts where we have agents generating fresh brand new prompts, right? easier to create than it is to update to level seven. Where effectively we're having our agents update our agents. How? By having our prompts update our

our prompts update our prompts. Okay. And so the best pattern I've found for this is with a dynamic expertise section. So this prompt grows, it becomes more proficient, it gets updated on a specific area in your codebase in a specific way and a specific fashion. You can see here with the hook expert planner, you can see exactly what this does, right? The trick here is in how do you update this expertise properly, all right? So this is a very advanced pattern. As the complexity increases and the

complexity increases and the level increases, these prompts are also more rare, right? It's unlikely that you even have a use case where you could really dig into this and get value out of this. But if you do and when you do, these prompts are absolutely insane. We're basically updating the context inside of our prompts in a live way. There are many ways to dig into this and extend this, but this is the beginning of this, right? You have self-updating prompts, okay? So very important, let's go ahead and place this, self-improving, we're

place this, self-improving, we're gonna put this right below the delegation, right below the template meta prompt, and actually we're gonna call this expert level. So this is very, very challenging to do and to write. The expert section in itself is less challenging to write than the actual full prompt, but we're gonna place these both at A tier usefulness, and we're gonna give them A and S tier skill requirement, all right? A couple of things we haven't covered in any of our prompts here, examples and the relevant files. So let's just go ahead and place is you've already seen this, right? Examples is when you detail some specific element of your prompt

element of your prompt to showcase what you want, either the output or some result to look like. This is very useful and it doesn't take that much skill to create. We're gonna put this in A tier right below variables, right? Because this can drastically increase your agent's performance. And then we have relevant files. This can be useful. This is a lot like code-based structure. When you specify a set of files, it's going to speed things up a little bit. It gives your agent a quick way to kind of reference and look at existing files. But this isn't like a

this isn't like a huge game-breaking deal. You've used this, you've seen this before. This is gonna be C tier usefulness, C tier skill requirement, all right? So this is our agentic prompt tier list. You're going to want to push to understand how to write template meta prompts because once you unlock this S tier skill and usefulness level, these template meta prompts at level six here, your agentic engineering velocity scales up very, very quickly, right? For you, your team, and your agents, specifically because you've

agents, specifically because you've templated your agentic engineering, okay? This is This is the big, you know, kind of the peak point of agentic prompt engineering. Once you can create the prompt that helps you create prompts, you start moving much faster than other engineers, right? Much, much faster. You always want to come in, update, tweak things, but your ability to have an agent, to have a specialized workflow, to have specialized sets of prompts that allow you to generate new prompts very quickly will separate you from the rest of the pack, all right?

the pack, all right? Because the prompt is the new fundamental unit of engineering. And with the agentic prompt that scales much further and much farther. And you know, to be clear here, you should be writing tons and tons of prompts. You want to be reusing, encoding, you want to be templating your engineering into your codebase in this new outer layer that we discuss at length intact. That's what this is all about. These are the seven levels. Let's talk about system prompts, versus user prompts. So the big idea here with a

idea here with a system prompt versus a user prompt is the scope and level of persistence. Okay. It's important to just say this. You likely already know this, but you've likely written like most engineers, hundreds and thousands of times more user prompts, probably even more than that, but more user prompts than you have system prompts. You have to be a lot more delicate when you're writing your system prompts. System prompts are rules for all conversations. The rules for for every user prompt you write. And the scale of

And the scale of the impact of this, when you're writing your agents, you only truly understand this and how important the system prompt is when you start building your own agents. To be clear, most engineers, as I've mentioned, you will likely not get to the system prompt level. But if you start building your own specialized agents to solve problems extraordinarily well, you will want to tap in to the system prompt. Okay. And in our background prompt, we did this of course, because we are spinning up a brand new Claude Code instance. This is primary agent

This is primary agent delegation from a delegation prompt and we appended the system prompt. Okay, so this is not a system prompt overwrite, which we discuss in the third agentic horizon extended lesson, where we focus on the Claude Code SDK for building out agents, right? We can do full system prompt overwrites, very dangerous, but very powerful. You can see here, we are appending key information that we always want our agent to follow, okay? So here we're attaching some information, we're actually building out a workflow into the system prompt. The system prompt

prompt. The system prompt is your AI's personality and the rule book, okay? So I'm not actually a huge fan of the role play. More importantly though, you wanna go into more detail, right? You wanna say what your AI should do, what it can't do, right? You're setting up rules, you're setting up the guideline, you're setting up the universe for your agent to operate in. The big deal here, right, the key difference, let's just go to the differences, right? The key differences is that your system prompts us the rules for every conversation You can't change this mid conversation. It needs to handle many scenarios.

to handle many scenarios. Mistakes scale to every user prompt you run, okay? You write this once and you run this many, many times, okay? So you write a single agent with one system prompt dedicated to a specific problem. And then if you deploy 10 of those agents, right? Say you're operating some like chat system or an agentic coding tool, whatever, every single user prompt hits that system prompt. right, every single one, and then it just adds your user prompt on the bottom, okay? So you can run, you know, we've all run, you know, some bad

you know, some bad user prompts, right? You just type in some garbage, our agent says, I have no idea what you're talking about, but I'm going to guess, you know, that's fine. You can just iterate to success, but we want to move away from that. And one way we can do that is, of course, first by writing better prompts, then reusing your prompts, right, that you keep firing off. You can create great reusable agentic prompts. But then when you keep moving up the stack, right, after you get to your ADWs, running specific agents, you can then build your own agent and give it a specific system prompt.

a specific system prompt. This is what we'll dive into in our next extended lesson, we're going to build specific agents where we're going to blow away the entire system prompt to solve your domain specific problem better than the out of the box Claude Code agent can or really any agent. This is the big difference, right? The system prompt is orders of magnitude, probably, you know, depending on how much you use it, we'll just say one order of magnitude more important. Really, I think it's more like two or three. Why this matters is pretty simple, right? A bad system prompt

A bad system prompt is bad instructions for the whole job, okay? The whole job. Writing this right is critically important. You know, we talked about a couple key sections for our user prompts and to be super clear every section we broke down here in our tier list, we're grading this specifically for user prompts, right? All of your Claude Code prompts, right? And all of your prompts that run in your agent, these go into your context window as a user prompt, okay? These are user prompts. Let's be super clear. Your system prompts, we only have like four system prompts in

four system prompts in this entire codebase. We have it right here, right? We're only modifying the system prompt here in this background agent delegation prompt. And then we have a couple of Claude Code which these themselves are system prompts. So this is an example of a system prompt where we're just saying, read this and use this as your system prompt. But typically you'll have something like this, right? So our doc scraper agent that kicked up has purpose. It has a static output directory. Remember there are no dynamic variables coming in

dynamic variables coming in to your sub agents other than the prompt that your primary agent passes in. This is the system prompt for sub agent. And then we have a workflow for this, all right? So the workflow step is useful. the report and response step can be useful, but you also don't wanna be too prescriptive with those steps, okay? Usually, you don't wanna be over prescriptive with your system prompt, okay? So for sub-agents, I think having a workflow is good because you want your sub-agents to do a specific thing, but for entire primary agent system prompts, you usually don't

prompts, you usually don't wanna prescribe a workflow, you don't have variables, outside of static variables. And you don't really want to touch reporting structures, although you can specify and steer the output if you want. Expertise doesn't really make sense. Templates don't really make sense. Metadata will all be passed in, right? Relevant files, code-based structure. These are not things you want to usually prescribe to your system prompt. All right, the key sections for the system prompt with the exception of workflow. You can have detailed

You can have detailed workflows in your system prompt. I'll go ahead and make an exception here. I'll move this one up. And because sometimes you will wanna prescribe a specific workflow to operate in, right? But you wanna be careful here because you don't wanna take away too much agency, right? And workflows reduce agency to increase determinism, right? You're gonna be a step-by-step play with an agent with the system prompt specifically, you really want your workflow to be a loose structure of what you're trying to accomplish. And usually that's accomplished with these sections, all right? Purpose,

sections, all right? Purpose, instructions, and examples. This is something we're gonna look at directly in our Claude Code SDK extended lesson. We're going to build out specific agents with specific system prompts and really showcase the impact, the massive impact they have over your user prompts. But the ideas are quite similar, right? You set up a purpose, you give them a large set of instructions, and then you specify some examples of how to do things, of how to use certain tools, so on and so

so on and so forth. All right, we'll talk about that more in that lesson, but I do wanna highlight prompts since we are talking about agentic prompt engineering. The system prompt is a key part of that story, but really 90% of the time for most engineers, all we need is one of the seven levels of agentic prompt formats. And then we need to learn how to interchange the right section write the kind of swappable sections, the swappable Lego blocks throughout the prompt that you're writing with the most important section by far. You know, I'm highlighting

You know, I'm highlighting this over and over for a reason. Most important section you'll write is the workflow, right? Your step-by-step play for your agent, for your agentic prompt engineering. There are two big ideas here that we've, you know, hit over and over and over. Communicate extraordinarily well to your agents, for the best results. Secondly, use consistent prompt formats and their interchangeable sections so that you can crud reusable prompts for you, your team and your agents. Okay, you're gonna be creating, reading, updating and

creating, reading, updating and deleting your prompts at light speed, at the right level, usually level three, level four is all you need. Get that great, powerful workflow step built inside of your prompts. Be consistent with your reusable prompts so that you can fire your prompts off over and over and over and reduce confusion for yourself in the future, for your team, and most importantly, for your agents. Your agents will be able to reason about many different prompt structures, okay? But engineering is not just about your agents. It's

about your agents. It's not just about you. It's not just about your team. You need to hit the trifecta, all right? The stakeholder trifecta for the age of agents. There's a new user, there's a new profile, there's a new type of consumer of the work that you're doing. It's your agent. So we need to be thinking about this trifecta as we're writing great agentic prompts. Consistency is king when it comes to writing great agentic prompts. You know, there are other sections that we didn't work through. There are other ways to express

other ways to express these sections, that's not what's important here, okay? The key idea here is that you have swappable Lego blocks that are the sections of your agentic prompts that each have distinct uses and capabilities that you can use for repeat success in your agentic engineering, okay? The prompt is the fundamental unit of engineering. Invest in your prompts for the trifecta to achieve asymmetric engineering in the age of agents, okay? Context engineering is very important,

engineering is very important, but your prompts kick off dictate everything you do so here's your next move here's what i recommend you focus on next if you haven't finished tack finish tack that is more important than context engineering is more important than agenting prompt engineering that sets up the future of engineering it helps you move toward becoming an irreplaceable engineer in phase two of the generative ai age okay so take tack next i'm going to recommend You go all the way to the third level and jump into writing customizable agents for

writing customizable agents for your domain specific use case, for your domain specific problems. I recommend you check out the Claude Code SDK mastery to build your own specialized agents. TACT is all about scaling up what you can do with agents. It's about getting out the loop. It's about exiting this simple back and forth prompting experience with these agents so that you can scale up what you can do by building pipelines that do one thing extraordinarily well. Use these seven levels

Use these seven levels of agentic prompt formats to guide your agentic engineering. Use the sections underneath interchangeable and focus on getting use out of your agents, right? Start at the lowest level, just throw it into a level one ad hoc high level prompt. And then when you need to scale it into a workflow prompt, this is gonna be where you get the majority of your prompt output from the step-by-step play of what your agent to do. After that, you can scale up and stack up your capabilities leading you all the way up to the powerful

up to the powerful template meta prompt, the prompt that builds the prompt, the agent that builds the agent. This is how you scale hard and fast in to the age of agents. And this is how you become an agentic engineer. Great work here. This codebase is going to be available to you. That's going to be available in your loot box below. I'll see you in the next extended lesson.
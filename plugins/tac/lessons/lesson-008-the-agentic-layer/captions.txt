# Lesson 8: The Agentic Layer - Video Captions

Source: Tactical Agentic Coding Course by IndyDevDan
Duration: 1:03:31

---

Welcome to Tactical Agentic Coding, Lesson 8, your final lesson. Everything we've done so far has led us here. You have all the information you need to become an irreplaceable engineer in phase two of the generative AI age, the age of agents. In this lesson, we cement this lesson, we cement critical Agentic Coding ideas, tactics, and beliefs by revisiting the atoms that make up everything we'll do as Agentic Engineers moving forward. We understand that these tactics, they're not bound to the software developer lifecycle or any specific engineering workflow. They're here to serve your engineering. They're building blocks for you to use to compose repeatable solutions for your agents. When I say build the system, that builds the system, that builds the system, we're talking about the new agentic layer of your codebase. Imagine a ring around your codebase. At first it's thin, then it becomes thicker as you scale agentics into your codebase. Machines that operate with your judgment, shipping your way getting work done autonomously in your product. In this agentic layer, this is where you template your engineering and teach your product to build itself. This course in its essence course in its essence represents an opportunity for you to pull the future into the present. There's engineering work you're spending time on that you don't need to be. As time goes on, as tools improve, as models continue to progress, you'll be able to hand off more and more work to your agentic layer. The irreplaceable engineer we set out to be in the beginning of this course operates differently than engineers of today. We build the system that builds the system. We operate on the agentic operate on the agentic layer much more often than we operate on the application layer. At the end of this course, there'll be a single guiding question you can use to know whether you're moving in the right direction or not. This guiding question represents the oil of this course. All the Agentic KPIs, every tactic, it compresses all of it into a single question. When I set out to create this course, I wanted to create a tactical day to day useful set of information for set of information for you. And that's what I've done here at the end of one last question for you that represents this entire course, but we have important ideas to discuss before we get there. In this lesson, we'll work through four unique codebases, each with their own agentic layer. The whole point here is to give you hands on quick starts you can use to build that V1, that proof of concept, that minimum viable agentic layer of your codebase. Let's cover your final tactic of Agentic Coding. tactic of Agentic Coding. Prioritize agentics. This tactic has been staring us in the face the entire time. This tactic can drive massive return on investment decision-making every single day you work and build with agents. It's simple. It's everything. Prioritize agentics. More specifically, prioritize your agentic layer. Agentics refer to systems or entities capable of autonomous action and decision-making. This tactic represents all This tactic represents all others, from target zero-touch engineering all the way back to stop coding. All tactics are compressed into this tactic. Prioritize your agentic layer. Prioritize agentics. The trick of this tactic is that it will fluctuate, but as a general rule, the more time you invest into your agentic layer, the thicker you make that layer around your codebase, the more your agentic layer will be able to solve problem classes on your behalf. As a good starting point, I good starting point, I recommend half of your engineering time, at least half, should be spent on the new agentic layer. And of course, when you're starting out, when you're building it initially, you're gonna wanna put in a lot of upfront effort. So let's make this absolutely clear. There's the agentic layer, and then there's the application layer. And inside application layer, I'm being very vague. We're talking DevOps layer, infrastructure layer, database layer, and the actual raw application layer, okay? It all goes under there. There's the application layer, and there's your agentic layer. I recommend more than half of your time should be focused on the agentic layer. As we work through these final codebases, Keep your eyes on the primitives. Keep your eyes on the composable units of Agentic Coding that make up the work that you're going to see. Focus on the pieces that make the whole, from the individual agentic prompts up to the composed multi-step AI developer workflows. This is what matters. Not the software developer lifecycle, not a model, not a tool, not Claude Code. It's the primitives, right? It's the primitives, right? And to be clear here, Claude Code represents the first viable engineering tool that unlocks agentic engineering, that unlocks agentic coding, but it won't be the last, okay? We know tools will change and models will improve. We can't fixate on these, okay? I've talked very little here as you've noticed throughout the course I've talked very little on clog code specifically this is very intentional okay this is not a clog code course very clearly this is a course this is a course on Agentic Coding tactical Agentic Coding key ideas you can bring to the battleground of engineering with agents every single day okay that's what this has all been about and in this lesson your final lesson we close the loop on this course. Let's start by pushing you toward the minimum viable agentic layer. Let's work our way through different examples, different shapes of what this agentic layer can look like. You'll see a lot of similarities. I've repurposed a lot of the work lot of the work we've done up to this lesson throughout these codebases, but keep your eyes on the primitives. As usual, we're gonna open the terminal. Let's clone in the lesson eight codebase. We'll CD in. If you type LS, you'll notice we have five distinct Now I might update this architecture to make this simpler and flatten them all. But at the time of filming inside this code base for simplicity, we have five distinct applications. We're going to work through three to four of these. Let's start with the agentic layer primitives. The agentic layer primitives. The agentic layer primitive codebase is a simple, empty code base you can use to understand and use as a great starting point to build out your agentic layer. Let's start with the readme. For your minimum viable agentic layer, you really only need these pieces. AI developer workflow directory and prompts. We're using Claude Code, so we store our prompts and .Claude commands. And then we have our plans. This is the minimum set of pieces of information that you need, right? Some type of scripting layer, right? I scripting layer, right? I don't care what you use. Throughout TAC we've been using UV single file scripts for ADWs. This is great because we can reference other files here. Our prompts are of course, markdown prompts and our specs are of course in markdown as well. You can use any type of script that you want. If you like TypeScript, use bun. If like Python, use UV. If you like the old school shell scripts, use shell scripts, it doesn't matter. The only thing that matters is that you can compose code and reference other files and have this be isolated from your be isolated from your application layer. Okay? This is a really important distinction. Our application and our agents, right? They're distinctly different. Okay? Our apps is in a completely separate directory that our agentic layer, our agentic ring can operate around. And so of course, None of this works without the prompts, so we need the prompts. And your AI developer workflows allow you to combine the old world of deterministic guaranteed code execution with the new world of agents. That's why we need the ADW's directory. If you're just operating with prompts, you're missing out on tons of capabilities, right? You're missing out on tons of workflows. So what does a minimum agentic layer look like? You can always start with a simple prime command, okay? This just sets your agent up and it's a prompt you can reuse and any one of your other prompts if you need to, to get your agent ready to work. And as you know, we can always fire this off. We can start a Claude instance here. We can run slash prime. can run slash prime. This gets your agent up and running, understanding your codebase very quickly. And now it's important that this is a standalone file. There's going to be different types of priming. You can prime different sections of your codebase. You can have prime commands for all types of things. This is a simple application. So we have a simple prime command. Okay. And you can see here, we have a great breakdown of this application throughout tactical Agentic Coding. We've been storing our logs in the agents directory and a log directory and a log directory. This lets us tap into exactly the work that our agents have done. So here's a V1 setup that you can use, right? You have prime, we have start, right? So you're gonna wanna start up your application. We can boot up in the loop, type slash start, get our agent up and running, right? Fire off the code. You can see here, we just have a simple UV run and a bond run, but this can be as complex as you need it to be to start your application. Your agents are handling, managing your codebase, running your codebase, restarting your codebase, restarting processes, so on and so forth. And then we get to the interesting bits. So we have a implement command. Remember, this is a higher order prompt. It's a prompt that takes another prompt as an argument, right? We pass this into the prompt. And then of course, we have a very important piece of the agentic layer, your templates. These are meta prompts. They template out what your engineering workflows look like. Okay, if we collapse everything here, you can see a classical markdown prompt structure. And what we have here what we have here is very, very powerful. We have plan format. Do not underestimate the plan format. We're having our agents do work. They're researching the code base and they're going to plan work, create a plan to complete the chore described. And so this is a V1 template meta prompt that you can use to get started automating work inside your code base. This is powerful because we're taking a high level prompt that will pass into this and then our agent will do the research on our behalf, right? It can search your It can search your codebase, it can navigate, It can make connections faster than we can, and it's going to continue to improve faster and faster, and it's going to get better and better. Okay, so here we're templating our engineering. And while we're working through this, right, while you're building out your meta prompts, you want to be thinking from your agent's perspective. Is this the engineering workflow and the pattern that you would use to solve the problem set at hand? And notice how we're focusing on problem sets. We're focusing on problem classes, not one-off fixes, classes, not one-off fixes, okay? You wanna solve the class of problems that you're approaching. And you can do that by templating your engineering inside of these powerful template meta prompts. This is a prompt that generates a prompt. And then of course, we can have different variations of this, right? This is a template that solves the problem of fixing chores, right? We can also have one that ships features. Okay. And so here we have more details. We have more information, but it's the same idea, right? We have a right? We have a prompt, we have instructions, we have code-based structure, and then we have the plan format. Okay. This is all familiar. We've worked on this. These are key parts of the 12 leverage points of Agenda coding. We have the in-agent leverage points, the core four context model prompt and tools. And then we scale that further, right? You have specs, you have templates and you have ADWs. So let's talk about the highest abstraction level. Once you start collecting your prompts, once you start using them right in using them right in the loop, you want to quickly start moving out the loop and you want to quickly start scaling up and chaining together useful pieces of Agentic Coding. The best way to do this is to get outside the agent, get outside the prompt interface, right? Whatever application you're using, you're gonna be watching this in the future. Claude code will very likely still be around, still be very powerful and useful. But the whole point is that you're detached from any tool. It's just about Agentic Coding. It's about tactics that you about tactics that you can use to agentic code. And one key concept, the highest level of abstraction is the AI developer workflow. We have a dedicated directory that uses these prompts. Here, our agentic layer really starts to take shape and starts to take form. A great place to start here is just the ADW prompt. You can literally just come in here and prompt against your agent. And this script is super simple. It's got really great concise logging. You can use this to understand where this to understand where and what the output looks like from this Claude Code agent. This is where it all starts, okay? So we can just quickly run a concise prompt here, clear this instance, paste this, and I'll just say, list all files in the ADWs directory and a concise output of their purpose. So we can paste this, I'll update the path to ADWs, and then we can execute this top level script. This ADW is calling an agent, okay? This is distinctly different from any other type of code. Okay. This script is the gateway into agentic coding, right? It's the minimal version of what you need to get started. And yes, it is just calling a Claude Code instance and managing all the surrounding state. Just to mention it throughout the course, we've been calling Claude Code right through a bash command, but you can use the Claude Code SDK, their support for both Python version for both Python version and a bun version. I have a brief example here of the Python version embedded inside this module throughout the course. We go directly to the CLI just to get our hands on everything to have full control over how the agent is called. But you can see this agent completed and we have a concise output, right? Here's the raw output, the final message of our agent execution. And this makes up the foundation, right? From here, it's just about stacking and scaling your agents and your prompts and making them more complex, sophisticated, tying more complex, sophisticated, tying them together with the right engineering workflows that actually deliver work for you, okay? This is it. This is the thinnest layer. And now we can stack this up and start progressing. Inside of the ADW slash command, we can call any slash command we want. So say we wanted to run that slash start, we can Just fire this off and just like operating in a Claude Code instance, right? Just like being in the loop by creating a script that can surround the application, that can surround any unit of code, we are slowly code, we are slowly moving out the loop. right? I'm not responding here. I'm not having a conversation with the agent. I'm firing it off, having it operate, right? It's firing this slash start prompt, which literally could be anything. At first, you're fully in the loop, right? Operating inside of a Claude Code instance, right? Typing back and forth and back and forth. This is a great place to start. It's a great place to do deep work. It's a great place to update and work on your agent to glare. It's a terrible place to stay, okay? So many engineers are going to miss this mark. to miss this mark. When you have a successful product when you have a product that you're maintaining that you're growing the value of building an agentic layer is parabolic okay it's absolutely parabolic put 10 minutes in get two hours of value out or more okay and how do you do that you wrap your codebase in an agentic layer It starts then, it's not very useful at first, but as you keep adding new AI developer workflows and you template your engineering inside your code base and you make sure to always add sure to always add feedback loops so that your agent can ship and auto improve, this layer becomes more and more important, more and more valuable. Nice output there. We have all these extraction logs here we can take a look at. There's that full breakdown. There's that sjson array. We've got the final object and the custom summary that you can just build, put together whatever pieces you want to see. So again, this layer of control is really important. So we can just keep pushing that forward, right? So after you get the prompt, slightly at the loop and your slash commands and your slash commands again, slightly at the loop, you can then start building real AI developer workflows, right? Where you chain together multiple prompts. Here we have chore implement. This is ultra simple. It runs slash chore right here as a template and then it runs slash implement, okay? And this is, you know, there's nothing complicated happening here. It's a bunch of logging. I wanna really bring everything back to the fundamentals here, right? There's nothing complicated happening. We're running two prompts back to back in an agent. These are agentic prompts, so they're agentic prompts, so they're doing a lot more work than normal. We happen to be running a template meta prompt, right? This is the chore file. And then once that gets built, the chore response has this output. It outputs a plan path, and then we take that, and guess what we do with it? We pass it right into implement. If you look at implement, you can see that we have one argument, which is the plan. And this begins infinite combinations and composables that you can put together to solve real engineering problems. There are many, many ways to slice this, right? You can make a You can make a chainable ADW, right? A one, two, it just calls one prompt and then it passes the other end. You can make all types of configurations, okay? I prefer this nice explicit version. It's a lot more readable, understandable for yourself, for your engineers on your team, and of course, most importantly, for agents that you work with. This is the foundational layer, okay? And we can of course run this, right? So let's just go ahead, plan, build something simple. of main in app slash star, okay? And so this will unnecessarily plan and build. We plan and build. We don't need this much compute for a simple task like this, but I just wanna showcase that you want complete control over your agentic workflow. The best way to do that is you don't wanna keep them in prompt form. You wanna scale them up and fuse them with the non-deterministic world of raw code. The whole point here is that you can use your prompts inside of this new agentic layer and scale up and build out unique developer workflows that solve sets of problems. Right here, of problems. Right here, we're creating a plan and we're building. The way we plan and the thing we build completely depends on your use case, but you can see here we have a plan generated, right? It's gonna be super, super simple, but it has all of our engineering practices encoded from the template meta prompt. And then of course apps right here, we're gonna see this new file pop up here in just a moment, right? We're implementing the plan. There it is, main.sh, great. And our agent will love likely automatically validate this. Yeah. So it's going to run this. It's going to do this work for us, right? work for us, right? So this is a simple example. I'm spending a lot of time here on the primitive layer because I want you to understand that this is the starting point, right? This is the thinnest possible layer. We're going to look at more complex examples in just a moment here, but this is where you're going to want to start. Okay. Prompts, AI developer workflows that you can call that you can now compose arbitrary amounts of code and agentic prompts together, right? It's the combination that really matters. Great. We're gonna move faster to the other examples here and showcase examples here and showcase the result of the agentic layer, right? Showcase what the agentic layer will give you as you make the layer thicker and thicker and thicker, and as the agentic layer operates on your codebase, okay? So this is fantastic. Let's go ahead and open up. the next layer back in tech eight. Let's open up the multi-agent to done application, not to do to done. Okay. So to done, what does this do? If we open up our apps here, you can see we're working in a data science, classical Jupiter data science, classical Jupiter notebook scenario. So we can execute this top to bottom and we can just see that we're operating on a simple tweets CSV file and just looking through a bunch of tweets and running some arbitrary analysis and classification on some tweets sentiment distribution 5050. That's definitely not the true distribution. But you know, you can see here, we just have a simple Jupyter notebook where we're doing some data exploration. Now, all of the application level work that we've done here, it's all example codebased work here. So this isn't here. So this isn't important. Okay, what is important is our agentic layer. So whatever type of application layer you're working with, every one of these agentic layers can be built for your codebase. All right, keep that in mind. Now, how does this work? We have a simple task management system. You can see we have this file down here, tasks.markdown. Let's open this up and break down what's going on here. Just by looking at this file, you should be able to understand that we have a multi-agent Git WorkTree based system here. And so again, this is just another way you can organize. I'm you can organize. I'm going to paste in a new set of prompts here for our task list. So I'm just gonna paste this in. We're gonna have our agents get to work on this, okay? So you can see here, we're working across five Git WorkTrees. They're just going to do engineering work for us, right? Across five WorkTrees. So let's kick this off. We of course are going to open up our AI developer workflows. This is where the agentic layer is managed. and we have our trigger. So our trigger is how we stay out the loop, right? This is pushing us from in loop to out loop and to out loop and eventually to ZTE. All we're gonna do here is kick off our ADW. So I'm just gonna open this, copy the relative file path, UV run, and we're gonna kick this off. And this is gonna be really interesting, okay? So we have a gray area in loop, out loop system here. We're operating on this kind of shared task file. Every five seconds, our trigger is going to pick up on tasks that need to be operated. And so you can see here, it found seven tasks to kick off and we're now going to start creating these work start creating these work trees. Okay. So these are dedicated environments for agents to work in, right? We're scaling up. This is an example of a thin agent layer scaled up just a little further. Okay. We have this simple multi-agent system where we can delegate work. And there's something really special about this, right? This is a powerful system for work, like data science for data engineering work, because oftentimes when you're building out these classifiers, when you're building up models, you're running multiple versions, multiple experiments, right? And so this right? And so this is a powerful way to do this. You'll notice something very powerful here too at the end. At the end of some of our tasks, we have tags. And so this is, as you can imagine, arbitrary information we're passing in to our AI developer workflows, right? That changed the way the workflow runs. Opus obviously kicks up our model, and then we have a ADW plan implement update task. So this is going to run a different AI developer workflow for this set of work. You can see where this goes. You can see our agents are, I'm not doing this by the way, right? This is way, right? This is all our ADWs and our agents starting to pick up work and get to work. So we're scaling outside of the traditional UI, right? We're pushing past the overkilled chat-based UI, right? We have a two-way task list and you can see this yellow kind of sun emoji here and a git commit hash. This uniquely marks this agent executing on work, okay? You can imagine as I work here, you know, throughout my day, I review this work tree and as results come and as results come in, I can just add and update tasks as my agent completes work, okay? So this is a small tweak. This is one or two files of our agents. And all of a sudden we're able to do a lot more with a multi-agent dedicated workspace system. Let's go ahead and take a look at what this looks like, right? So you can see very, very similar setup, right? AI developer workflows. And then underneath all that is our prompts that run. Same pattern. You're gonna see this over and over. These are the atoms. You can see we got another commit message there kicking off. We're adding kicking off. We're adding 25 edge cases to our tweet CSV. We need to do some update work for the CSV to make the data richer. Whatever work you're doing, you know, you can agents, they're operating on this, right? So this is very cool. You can see one of our tasks completed. We have the ADWID and the Git hash. And so we created this filtered data set, tweets positive only. Okay. And so how does this work, right? It's all thanks to our agentic layer. This is a slightly thicker agentic layer. We're running our cron trigger. I'm our cron trigger. I'm not gonna dive into all this. You have all this code available to you, right? So after you finish this lesson, your final lesson here, dive in, understand what you can do. Okay, these are all example starting points. Then same kind of deal here, right? We have that same ADW prompt, we have slash command, but then we have real useful composed developer workflows, right? Workflows that put together prompts and code to do real engineering work. Most of these workflows are just going to kick off the build update task. If you just search for build, update task, for build, update task, you can see that's that workflow script that's getting kicked off there by default. But if we pass in our upgraded ADW ID, it will also perform a plan implement, right? So it'll run this other AI developer workflow. Okay, so our trigger helps us stay further out the loop so that we can operate more quickly, right? We're not prompting back and forth and back and forth. We're scaling up the number of agents we're running with this task-based system. Prong trigger helps us do that. And you can see here agents are just rolling agents are just rolling in work, right? They're rolling in work. And so you can imagine what these emojis are, right? Check means done. And we have this timer. This means blocker. So you'll notice, you know, this timer here, didn't start until the two above were checked off. Okay. So this is just an arbitrary agentic layer. I just built this out this way. Okay. You can build it any way you want. That's great. And so, you know, same deal here, right? If we jump into build update task, we can just slash search, always just slash search your prompts. You can see there, we initialize see there, we initialize the work tree. That's one important piece. And then we of course just call build. right slash build with the task. It does the work, writes the commit message and we can, you know, look at build here. All of this can be done in the loop, but that's just the place you want to start. Okay. Of course it can be done in the loop, right? This is the lowest hanging fruit of Agentic Coding. Course you can open up and just write the prompt yourself, right? And do the work yourself, but that's not the point. You can't scale that way. Okay. Remember prioritize Agentics. Prioritize Remember prioritize Agentics. Prioritize the agentic layer of your codebase. Don't do the work by yourself. Teach your agents to do it. Teach them how to solve the problem class. Build the system that builds the system. We're operating on that new agentic layer. Prompts composed into AI developer workflows. Okay, but you can see here, you know, we're just passing that task description and then just gonna start do a couple simple things, research, implement, test, commit. This is more of like a quick patch. And then we have more sophisticated tooling. We have a plan implement workflow, right? An architect and right? An architect and an editor, ultra powerful pattern, especially when you combine it. with template meta prompts, which of course we have here, right? We have our plan prompt. This is a generic plan. It's not, you know, a chore or feature. It's just a plan, right? Just super general, super vague. You will be able to outperform these by going more specific, but the simple plan prompt is a great place to start. So same deal there, template meta prompt, very important. This is a key leverage point of agentic coding. You already know that. We don't need to revisit that. You can see here, we can see here, we divided up our ADWs and a couple of sub directories, just making things a little easier to work with, right? You will get to a point where your ADWs in itself, in combination with your prompts, is its own kind of micro codebase, right? A wrangle layer around your codebase. And so you do want to put good engineering patterns and practices as you scale it up, but keep it separated from apps. Okay, keep it isolated and separated. This is not the application layer, make that clear. So let's go ahead and take a look at what's a look at what's been done, right? If we look at our work, our agents are just cooking, right? They're getting work done for us. I throw in, what did I throw in here? Seven, eight, nine, something like 10 tasks and it all started in parallel on these separate work trees. Okay, so let's just go ahead and validate some work. Okay, so enhanced, data training. So what we can do here is open up trees and you can see we have the enhanced training data directory and I can just CD trees or actually CD trees or actually I'll do this. I'll do code trees and then I'll paste this in and we're going to open this up and check this out. Right. So we have a sparse checkout of just this directory, just this codebase that we're operating in. Right. So it's a entire copy of this environment of this codebase for this agent to do just this set of work in, right? So let's look for this tweets positive only that will come up probably pretty quickly. There it is, tweets positive only, right? If we look at the sentiment, we can just search we can just search positive and you can see that's all we have here. If we regex search negative, we have absolutely nothing, okay? Great, our filter tweet worked. You can see code came in and operated here on this work tree and we added 50 new tweets. And right now another agent is building out an augmented training model using both original and filtered training sets. So it's using both of these now, right? So it's stacking on the work that's been done. Lots of places, lots of ways and directions you can take this. you can take this. Let's go ahead and move on to another agentic layer. Remember, it's all about the agentic layer. There's so many possibilities here, so many combinations, but Here at the end of TAC 8, I just wanna give you concrete starting places and ideas for you to start building your agentic layer, prioritize your agentic layer. Let's go ahead and skip app three. I'll let you open that up on your own and look through that. I wanna get to agentic prototyping. All right, so go ahead and open this up. So we're gonna code this. So we have this code base here all set base here all set up. And what does this do? What is agentic prototyping? prototyping do. This one's really cool. We're fully out the loop here. Prototyping is ultra important with the insane pace of innovation in the tech ecosystem. You want to be able to prototype quickly. We can of course throw agents at this problem. So I have a notion page here. and already you understand what this does already, right? We have an agentic prototyper as a notion database in the board view, okay? So board view, okay? So this is just a classic board view and you can see here, we have multiple simple examples of prompts right, coming right out of a Notion database. There are of course many ways you can tweak this and use this and improve it. We should have a lot of our tags as properties, but that all doesn't matter. That's all based on how you wanna set up your agents and your Outloop agentic systems. Remember the Peter framework. You have prompt input. For us, it's this Notion page. Environment, this is going to operate inside the to operate inside the trees directory, which doesn't exist yet here, right? We're gonna use dedicated Git work trees. And then we have the review system. And so the review system is gonna be both the actual codebase results right inside the editor. And we're gonna get high level reviews as these tasks progress. So let me just go ahead and kick this off and it'll all make sense. If you wanna understand the agentic layer, you open up ADWs, okay? And if you wanna stay out the loop and look for that starting point, you open up the triggers. Here we have ADW trigger cron notion tasks. So another cron job that is going job that is going to execute. Let's go ahead and run UV run, fire this off. and we're gonna monitor and pick up Notion tasks every 15 seconds. And let me actually just reset this. And let me just do this a faster way. I'm gonna pass in the once flag. Use this for quickly testing. It's just gonna run the workflow one time and just pick up as many tasks as it can. So yet again, another configuration of your agentic layer. I'm not gonna dive into this one. I think you're getting the pattern. You're starting to understand what's happening. If you ever wanna find the prompt, you just look prompt, you just look for slash, right? And there it is. Update Notion task, make work tree name, init work tree, get notion tasks, so on and so forth. And then we have composed AI developer workflows that actually do some work for us. Okay. There's plan update, so on and so forth. You can see here our cron, right? Our trigger in the Peter framework, our trigger is starting to pick up tasks and check that out, right? It agentically picked up and moved that task for us. And our agent is now going to start working. If we open this up, you open this up, you know, we can always just monitor and write whatever report status update messages we want to. This is yet again, another Outloop system. You can wire up to agentic code, right? To build with agentics, to have your agents operate on your behalf, generating a work tree name. Great. work tree created and always, right, as always, you can open up dot Claude, right, go into commands and just see all the possible agentic capabilities, right? possible agentic capabilities, right? Now it doesn't tell the full story, right? This won't tell the full story. If you're bouncing your deterministic code with your non-deterministic agentic prompts inside of your ADWs, right, you're going to need to read both of these to get the full story. But the primitives here, right, the atoms of Agentic Coding, they are your prompts. This is part of the core four. This is part of the in-agent system for a reason and a through-agent leverage point is because everything is based on this, right? Plans, prompts, templates, ADWs, Plans, prompts, templates, ADWs, okay? And then we have auxiliary leverage points, of course, right? Types, tests, code-based structure. You can see here, we're just gonna start to get to work. So multiple agents, again, getting their own separate isolated environment to work on some arbitrary task. What's the value proposition here? This codebase in particular specializes in creating prototypes. We have that classic plan. So this is not new, right? This is just a plan template meta prompt, very powerful, very useful, very powerful, very useful, but we can go even further, right? Specialize, right? Do something, take care of some type of engineering work, right? That's what your ADWs and your prompts should do. Solve a real problem. Let's look at our UV MCP. Okay. And so what does this do? This is another template meta prompt, but instead here we have another variable that's going to get created on the fly here by our agent. And what's going to happen here is we have a dedicated workflow and we have some additional AI docs, right? So this is another kind of important auxiliary directory, of important auxiliary directory, just paste in whatever documentation you need. But here we have a prompt right, a meta prompt that builds out astral uv python model context protocol servers. All it needs is a prompt and then it builds out an mcp server, right, based off the documentation and our request, okay. And you can see here very clearly right, template meta prompt, same structure, nothing new happening there. You already know about this, you already know about writing great prompts. You know, you can scale this to whatever type this to whatever type of codebase you want to prototype, right? You can imagine how useful this can be. And so let's go ahead and just quickly check in on our task. In progress, not started, that's fine. Looks like we picked up three. So you can see here, we have plans successfully created, plan, JSON format or bun script, looks great. We have, right, we have another agent getting kicked off here, UV watch file, so on and so on. forth right uv plan script and our agents are just going to progress here I'll probably skip through some of this to save some time but you can see the workflow right let me zoom out a little zoom out a little bit so you can see the done column as well not started in progress human in the loop review failed and done and you can just manage everything here always remember the peter framework this is a review system that you can use to just quickly operate outside the loop whenever i need to on my mobile device on a different device you know even sitting right here right I can just quickly gather some documentation write up a quick prompt. fire off one of my templates and generate an entirely new application here at light speed, right? This is something your agents can do, right? Yet another do, right? Yet another example of work that you don't need to be doing if you invest into the agentic layer of your code base. All right, so you can see here we're on the implementation step. You slowly want to progress from in loop to out loop and the north star from lesson seven, you want to target zero touch engineering. This is what's going to happen naturally as you continue to improve your agentic layer. Soon you won't need to review. I know that sounds crazy, especially if you're finishing this course earlier on in the timeline of in the timeline of generative AI. This is just where everything is going and you want to lean forward. So check this out. We have phase two implementation successful. This is our MCP system info server. And so let's just go and check it out. Feature MCP system info. So this is an MCP server that gives us system information, accessible to our agent. Okay. Let's do code trees, feet, MCP. And I'm just going to go all the way into this here. So this is the environment that that agent completed that that agent completed its work in. And you know, you can see here that it moved to done. It looks like another task got completed as well, but this is finished. And if we click this, you can see, Live updates, right? There's its summary. And of course, this is a presentational example. I've just kind of breezed through what this could look like, but you can put anything you want here. You wanna be observing and monitoring your agentic system very well in your Outloop review system. Again, just examples, just working through this with you so you can understand, right? Everything I'm doing here is built to help you understand what you can understand what you can do, okay? So let's look through this here just super, super quickly. I don't wanna harp on the exact details too much, but you can see an environment all set here and what did this do so apps sys info mcp great what i want to do is understand what this does so I'm going to open up the readme that agentically generated and I just want to see here we go right I want to see that dot mcp dot json file I'm going to create this at the top right dot mcp dot json right so if i just open up cld now claude get there now claude get there we go get memory info mcp Get memory info. So I'm just running a random MCP tool that created by our agents and check this out, right? That's working perfectly. There's my memory usage, 128, use 32, available 93. Fantastic. Okay, so not to get too much in the weeds of this exact tool, but we can just do this. and we can do this as well, right? Get CPU, get disk. Our agent created this for us end to end, okay? You don't need to be doing so much of the so much of the work you're doing, getting really full on space there, but we created an entire MCP server with a single prompt. Let's look at that exact prompt, right? Look at how concise this is, right? Create a concise and minimal model-concept protocol server that provides system information, blah, blah, blah, blah, blah, okay? That's it, execute, okay? I have solved the problem class of building Astral UV model context protocol servers. Okay? I've solved it. It's done. Okay, this is the power of the agentic power of the agentic layer. This is the power of building great prompts, investing in your agentic layer, investing in the prompts, investing in the ADWs, understanding the 12 leverage points, right? This is what it's all about, okay? We're solving multitudes of engineering problem here, right? We have this UV watch that was created. We have this BunScript watch application that was also created for us. Look at our velocity. Our velocity is absolutely mind-blowing. We have to move on. here you know check your loot box check your loot box all this is going to be available to you don't fixate on the exact details focus on the agentic layer okay prioritize your agentic layer let's look through one more example and then let's set the table for the current phase of Agentic Coding that we're in the current age of agents okay so let's wrap up one more example I have something exciting that I want to share with you here if we open up our last example here we have something familiar that you've seen before. that you've seen before. So let me just go ahead, shscripts start and shscripts aeserver start. And so we have something really, really, really cool here. So I'm gonna boot this open and you'll see something very familiar. We have the natural language SQL interface that we've been working in throughout the course. Okay. It looks like our exact same codebase. but this is actually very different. If we type command P here, slash AEA, we have an agent we have an agent inside of our app. We're talking with Nexus, hello. And of course we can do something really powerful. The power of agents isn't in one, it's in many, slash AEA, spin up another one, get some more work done. We're now talking to Roon as well. What is this codebase about? Okay, and then over here we'll say update the generate random query button in the what app is this app five, let's call it interface to be generate. interface to be generate. Okay, and so two agents operating for us, right? They're off doing work. How does this work? We broke one of our rules. Here we go, check this out. Very, very cool. We have a concise summary, right? We're talking directly to our agents from inside the application. If we quickly glance at the code, you can see the exact same structure. ADWs, this is the housing unit for the agentic layer of your codebase. And then we have .Claude with our prompts where we put it all together. This is all together. This is the lower level atoms that we compose together while using great leverage points of Agentic Coding. So it's all here. I'm not gonna go into this in too much detail, but you can imagine how this works. You understand this layer. We've been working on this. We've been talking about this. right, ADW trigger, we have a dedicated agent embedded application server so that we can access this outside the loop. In this case, outside the loop is inside the application. Okay, so there are many ways you can play with this. can play with this. This is a very powerful idea. You can see here our agents are doing work. They're responding to us. It updated this button for us. And this just goes on and on and on. I'm gonna stop here. There's a lot of value in this. This is a great place to branch away from the code itself, okay? The keys of the future of engineering are conceptual. It's all about the information you have, the details of the code, They matter, the details of the prompts, they do matter, which is why we've broken them down to individual tactics. But a lot of what a lot of what matters here is key beliefs around what is possible with agents at your side, with compute, with intelligence that you can now orchestrate. You can see here throughout these, you know, just three, four examples, there are many permutations of the agentic layer of your codebase. This is the place to focus, right? This is what it's all about now. You can see this is just a very primitive, presentational version. You can make your own fully built out agents inside your application that can operate your that can operate your domain, that can operate your problem set better and faster than you or any engineer on your team can, right? And that's the whole point, right? Template your engineering, give your agents your capabilities so that you can focus on the more strategic, higher level decisions so you can move up the stack, okay? So let's recenter around tactical agentic coding. What has this all been about? We set out on a single mission to become an engineer that can't replace. Here in lesson eight of tactical agentic coding, you now have coding, you now have everything you need to become an irreplaceable engineer. It starts when you stop coding. I can guarantee you the irreplaceable engineer of the future is not writing a single line of code. That's tactic number one. Let's just walk through these and understand what we now know to be true about agentic coding, okay? When you adopt your agent's perspective, you can build powerful agents that improve your Agentic Coding KPIs. You give them the tools that they need in their context model prompt their context model prompt and tools to get the job done. You then layer on 12 leverage points of agentic coding and you give them to your agent at the right time in the right place. Okay, we have in-agent leverage points, the core four context model prompt tools and through agent leverage points, right? Standard out types, documentation, tests, code-based architecture, plans, templates, and ADWs, the highest level of composition ADWs, code plus agentics. When code plus agentics. When you put those together and you give them to your agent and you adopt their perspective, anytime they're running, you'll understand how to build effective, powerful agents better than anyone because they have maximum leverage. When you do that, you can focus in more on the agentic layer and template your engineering. This is the way to set up and encode your engineering. You use template meta prompts. prompts that output prompts in specific formats with specific rules, guidelines, files specific rules, guidelines, files to read, conditional documentation, so on and so forth, right? You saw this throughout tactical agentic coding. You saw all of this. This scales to any codebase. Don't make the mistake of thinking that the simple toy examples we worked on here are a bottleneck in any way. They're not. Don't use anything as an excuse to slow you down here. I purposefully hyper-focus on the agentic layer throughout this course. Okay, now what happens next right once you template your engineering you start increasing your agentic start increasing your agentic coding KPIs right? What are those? They're the measure of your success as an Agentic Engineer Okay, you want to decrease the attempts it takes for you to deliver work with your agents you want to increase the size of work you can hand off to your agents you want to increase the streak of successful work you're shipping with your agents without making mistakes. And then you wanna drop your presence to the bare minimum. Presence is you showing up and writing a prompt and reviewing and doing work with your agent. You wanna drop this to zero. You this to zero. You wanna stay out the loop. There's in-loop agent decoding and there's out-loop Agentic. More and more as you progress, as you build up the agentic layer of your codebase, You wanna be staying out the loop. You wanna be building the system that builds the system. That underlines everything we've done here and everything you can do now. Stay out the loop. And how do we ensure that we can do that? We tap into one of the critical leverage points. We always add feedback loops. We add tests. Okay, We add tests. Okay, these are validation commands that your agent runs to confirm that their work was successful. Okay, in the software developer lifecycle, we embedded lots of testing, lots of reviewing, lots of validation in the test and review step. The software developer lifecycle is a fantastic way to understand what you can do with Agentix, what it looks like to automate end to end. It's a great starting example, but it's not going to be exactly what you need. You can build up any workflow that you need in any format. It's not any format. It's not about the software developer lifecycle at all. It's about the composable pieces of Agentic Coding that you can now put together to deliver more results in the agentic layer of your code base so that your agents can operate on your codebase. That's why we always add feedback loops. The big labs, the big three, Gen AI companies, they're all doing this right now, right? They have these insane feedback loops where agents are operating, solving problems, iterating on research over and over and over and over against some validation function. against some validation function. If they can do this at scale for serious, life-changing, world-changing problems, you can do this on your codebase. I can guarantee you there is a validation, a set of validations in your codebase that once run ensures everything works perfectly, okay? The only question is, do you know what it is, right? Do you know what those commands are? Always add feedback loops. Now, controversial one, but it's important. One agent, one prompt, One purpose. There are limits to what we can do with agentic technology, okay? Especially if technology, okay? Especially if you're further in the past and you're not that far into the future, context windows are still small. So how do we alleviate this problem? How do we sidestep it entirely? We focus on building one agent with one prompt with a single purpose. One purpose agents. You saw this throughout every codebase we worked in. We're running one Claude Code instance with only one exception, right? The only exception is This codebase, okay? This is the only exception to that where we are actually passing back in the session ID back into this ID back into this agent to continue the conversation, okay? This is the only exception to that. Every other prompt we ran, we have one agent, one prompt, one purpose, and I recommend that for the majority of your agent decoding. This creates focus agents, focus context windows, that are reproducible and easily testable, validatable, and improvable. Where does this all end up? It ends up with zero touch engineering. This is your North Star. This is the lesson seven tactic. Target zero touch engineering. As you progress engineering. As you progress and your agentic layer becomes ultra thick, something incredible will happen when you ship a workflow end to end and you really dial in the AI developer workflow. You will become a bottleneck in the process. The time you spend, the resources you spend reviewing the work will be useless. And then something incredible will happen. You realize you're the bottleneck and then you'll convert the Outloop framework from Peter to Pete. Prompt input trigger environment. No review. Okay. You'll drop the R off. This of course won't happen overnight. There's no black and white in black and white in engineering. There's gray, there's progression, there's one day at a time, one step at a time. So at first you'll just solve simple small chores end to end and then eventually you'll realize you don't need to validate this type of work and because you always add feedback loops and you have a concrete review step that you've taught your agents how to use, right, maybe it's images, maybe it's videos, maybe it's a multi-step review system, a multi-step review, ad developer workflow, whatever it is, right, remember you have all the you have all the pieces to build, whatever you need to now, you'll run this and that will be more than enough. Not only will you stay out the loop, getting in the loop will be harmful. So you'll drop the review process and you'll ship end to end. You will let your product ship itself. Target zero touch engineering. And finally, putting it all together, we prioritize agentics. If it isn't clear, this is the place, the area of focus of the largest return on investment. Let's be super clear. What be super clear. What is the agentic layer? It is the combination of traditional deterministic code that is stored in your ADW's directory as a scriptable layer that combines deterministic code with the new non-deterministic agentic technology, the language model, the agent, Claude Code, and whatever variants are gonna come next, right? You combine these two things. This makes up your agentic layer, the old world of deterministic old world of deterministic code and the new world of agentic prompts. This is the agentic layer. This is the layer that can operate on your codebase with the highest leverage point of Agentic Coding, the AI developer workflow. And so we prioritize agentics because our agents can ship better and faster than us. Don't make the mistake of thinking that you can outperform your team's best engineering practices encoded into a template metaprompt that runs in an AI developer workflow that kicks developer workflow that kicks off five to ten agents per problem. You know, like don't try to compete with that, right? Your place of competition is now net new innovation. It's building on the agentic layer. It's using compute to solve problems in an interesting way. And this is all because you can teach compute how to build. You can teach compute how to engineer your way. Okay. Here at the end of tactical Agentic Coding, let's take this all the way and compress our KPIs, our agentic concepts, our leverage points concepts, our leverage points and our tactics all into a single question. This leads us to the final question, a final meta tactic, if you will, that can guide you and direct you on a daily basis. Again, Tactical agentic coding. Everything you've done here, this entire course has been designed to be tactical. These are pieces of information you can think on a daily basis to guide you toward great agentic coding and therefore agentic engineering. This is the last question I have for you. This is the only thing you need if you forget everything else. This is everything else. This is the only question you need to win that can guide you. Okay, so right now on a day-to-day basis when you're working, ask yourself this, am I working on the agentic layer or am I working in the application layer? That's it, okay? On a day-to-day tactical level, even if you forget all eight tactics, this is all you need to think about. Am I working on the agentic layer or am I working on the application layer? The majority of your time should be spent, of course, on the agentic layer. Why is that? It's Why is that? It's because you can teach compute how to build. It's because you can teach compute how to engineer your way. It's because you can scale your compute beyond comprehension inside of the new agentic layer of your codebase where you're orchestrating intelligence. That's why. This is why we do it. Just like an engineer using AI will outperform an engineer not using AI, an engineer that is scaling up their codebase with fleets of agents with fleets of agents that solve problem classes completely outperforms an engineer using classical AI coding, classical in-loop Agentic Coding, okay? You will not be able to compete, okay? There is no competing with an agentic engineer. You must have fleets of agents operating on your behalf to compete with an agentic engineer. Now, the most important thing you can do next after you finish this course, this final lesson here in our last five, 10, 30 minutes together here is invest in this layer, prioritize agentics. On layer, prioritize agentics. On the day-to-day level, ask yourself, what layer am I working on? This is not the agentic layer. I need to spend more time working on the agentic layer so my agents can do this work for me, okay? That's the thought pattern. That's the thought chain. That's the flow chain. Because once you start getting to these aha moments, once you run a bug fix end to end with no intervention, once you run your first ADW that's useful for you, once your teammate runs one of your ADWs and they say, holy, I didn't do anything. I just described what I wanted and it solved the problem. it solved the problem. Now I use this ADW all the time thanks to you, right? getting these wins, you realize that there's nothing more important to be investing in. You'll fully understand tactic eight, prioritize agentics, prioritize your agentic layer. Of course, by investing in your agentic layer, you're actually investing in your application layer, right? It's all about your users, your product, and your company. This is a constant in the sea of change. This never changes, right? Never forget who this is all for. Customers, users, team, company, you. users, team, company, you. This all relies on you being able to invest in your agentic layer. Do not make the mistake of thinking you're smarter than your best engineering practices and your best team's practices templated into your agentic layer. Okay, don't make that mistake. Okay, because if you're not wrong today, you will be wrong at some point. These are massive mistakes that will prevent you from becoming an agentic engineer. What is an Agentic Engineer? It's the irreplaceable engineer that builds irreplaceable engineer that builds the system, that builds the system. An agentic engineer operates on living pieces of software that work while they sleep. And so this is it. This is the framing. This is tactical Agentic Coding. You have everything you need to become an Agentic Engineer now. All you have to do is answer the question every day when you sit down to work. Am I working on the agentic layer or am I working on the application layer? If you're working on the agentic layer, you're likely moving in the right direction. Command your agentic layer to your agentic layer to run and control your application layer. Okay, if you're working on the application layer, you must have a good reason right, a deadline, right, or maybe you're testing something, right, maybe you're running some of your prompts in the loop just to make sure that they'll work out the loop, okay, or else you're moving in the wrong direction. You're going sideways while other engineers that have taken tactical Agentic that understand what's here and what's coming next, what opportunity is available to them, they'll be moving up while you'll be moving sideways, okay, full stop, bar none. What stop, bar none. What you've done here in tactical Agentic is much deeper than you might realize, what you can now do is much deeper than you might realize. We've described the commoditization of implementation. AI coding is not enough. Coding has been commoditized, but what we're seeing here, looking through these examples, working through agentic layers, right, scaling up across the software developer lifecycle, what you've seen here is the commoditization of implementation and early signs of the commoditization of engineering, okay? commoditization of engineering, okay? AI coding is not enough. With Agentic Coding, not only is code a commodity, but the implementation as well. This is only a net negative if you show up late to the party. You are here very early. It might not feel like it, but you're here early. Allow me to help you step out the tech bubble. You know, you and I both live in. You are early, okay? You have this information. The value of engineering is actively moving up the stack to system design, system architecture, encoding your domain expertise for your agents, expertise for your agents, for your product, for your team, for your company, quality control, right? Validation review systems, and most importantly, creative problem decomposition, right? Which you'll then encode in your ADWs. This is bigger than a course. This is a manifesto for the next phase of software engineering. This is the guideline. This is the framework. This is the codex for agentic engineering. This is the groundwork for a new role of engineering, the Agentic Engineers, Agentic Engineering. Agentic Engineers, Agentic Engineering. You want to be one of the engineers that internalizes this and bets on this reality now. You don't want to fall behind. The Agentic Engineer builds the system that builds the system. Prioritize agentics. Thank you so much for trusting me. I have something to ask of you. I am just one man, one guy that tries to push what he knows to the edge over and over and over as much as possible. But no matter how much I push, no matter how I optimize my day, my time, my schedule, my life, my schedule, my life, my health, I can only do so much. So I have a favor to ask of you. Help spread the ideas in Tactical Agentic Coding. Share this course. Share the ideas inside this course with engineers that you know on social, on your private DMs, with your teams or engineers that you work closely with or coworkers that you know can handle the ideas that you think are ready for the tactics and beliefs inside this course. Word of mouth is the only true mark of success. I'm asking you here if you got value out of got value out of tech, thank you so much. Go ahead and share this with an engineer that you think could benefit from this. Massive thanks. from me to you. One more thing, your engineering feedback is ultra valuable. At the end of this course, you'll have the opportunity to let me know what you want to see next. I'm gonna lay out several ideas, several high return on investment directions for engineers, gaps in the market that I'm seeing. I'm gonna open it up to you. It's gonna be multiple options, prioritizable. So depending on prioritizable. So depending on demand, depending on what you choose there, I'll steer in the direction that accelerates the growth of as many cracked engineers like you as possible. So thank you that and that'll be available to you as you finish this lesson. It doesn't matter if you know that the future is already here. What matters is that you do something about it. You have to be the one that runs toward the future while others walk away, run away, stand still, or walk forward. You now have everything you need to win big in phase two of the generative AI age, the age of agents. the age of agents. You only need to catch one wave of change everything and if you do this right you will change everything in this phase there are two things that matter more than ever focus and signal without these misinformation hype trains and AI slop will lead you astray for valuable information sources for engineering in today's world and tomorrow's make sure you stay plugged in to the IndyDevDan YouTube channel I'm not going to stop until we cannot build any we cannot build any longer I'll be sharing current generation ideas surrounding tactical Agentic Coding. I'm going to hold off on a lot of the core ideas from the channel. I want to give you an edge and I want to give you a time advantage, right? A temporal advantage before I start, you know, talking about the details of this course, talking about some of the core concepts and bringing them to light so that you can have an edge here. I'll be sharing more about this course. I'll be sharing any potential updates. I'll be sharing next potential big ideas and whatever's big ideas and whatever's coming next. I'll be there every Monday for you and engineers and will be focused on the signal in all the noise. I don't have a ton of bandwidth. Nearly all my time is consumed by mastering agentic technology, but the time I do have, I come to the channel every Monday for you and for engineers. to distribute the insane potential of this technology. And every once in a while I create, you know, a full on cohesive piece like this Tactical Agentic Coding for you to Coding for you to give you a large edge. Make sure to follow the channel so you don't miss what's coming next. Generative AI technology is the most powerful technology of our lifetime. So this is the message I wanna leave you with. Imagine your future self looking back, feeling incredible, grateful, and happier than ever. Why? It's because you've won. You did it. Your product is successful. Your business is successful. You achieved the status, the respect, whatever you were looking for, you found it. You achieved your engineering dreams. And on that day in on that day in the future, you sit down, you start tinkering, right? You're building something just for the love of it, right? For no other reason other than fun. You start reminiscing about this period in your life when everything started changing. And you say this, when the agents arrived, something changed. We weren't just AI coding anymore. We started orchestrating intelligence. This closes the loop on Tactical Agentic Coding. In a sea of noise, slop, thank you for slop, thank you for trusting me with your time, with your engineering, with your future, with your career. I could not have created this course. I could not have created any of these ideas. without executing on them over and over and over and over, over years. So at the end of this course here, I want you to trust me one more time and put this information to use to change your engineering forever. If you do this right, it will change everything. Prioritize agentics. When the Prioritize agentics. When the agents arrived, something changed. We weren't just AI coding anymore. We started orchestrating Intelligence.
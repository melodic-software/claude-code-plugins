# Lesson 7: ZTE - The Secret of Agentic Engineering - Video Captions

Source: Tactical Agentic Coding Course by IndyDevDan
Duration: 53:22

---

Welcome to lesson seven, your second to last Tactical Agentic Coding lesson. Here we approach the edge of agentic coding. Here we ship end to end with our Outloop system to deliver more engineering value than we ever could before. In the next hour, you'll witness something most engineers dismiss as impossible, engineers dismiss as impossible, a codebase that nearly runs itself. This lesson is going to flow differently from the rest. First, we're gonna hand off five net new pieces of work to our agentic layer that now ships end to end. Plan, build, test, review, document. You'll see the order of magnitude improvement in your engineering velocity. You'll see what it looks like to fully invest in your agentic layer. We'll work through a couple of additions that helps us increase our engineering velocity with our agents. velocity with our agents. Next, we'll break down how we've parallelized our AI developer workflows using Git work trees. This enables multiple agent pipelines to execute simultaneously in isolated environments on a single device. Of course, you can tweak this and make it your own. You can set up your own containers. You can use Docker. We're keeping it simple and we're focusing on the key idea of scaling beyond what in-loop agentic coding can offer. Then midway through the lesson, I want to introduce you to the third level of agentic third level of agentic coding on the agentic engineering velocity scale. There are three levels in loop out loop and one additional level that we're going to break down in this lesson. Most engineers are operating in the loop throughout tack. You've learned how to construct powerful out loop systems that you're going to see in this lesson that clearly outperform out of the box agentic coding tools because they contain your engineering practices and your engineering workflows. But there's a level beyond Outloop a level beyond Outloop Systems. We'll understand a critical moment in the future where human in the loop review becomes a bottleneck, not a safety net. This tactic will lead us to the secret of tactical agentic coding. Let's collect the incredible dividends from our complete end to end Outloop agentic system. I wanna showcase that once you've invested in your Outloop system. Once you've built the system that builds the system, it's going to pay you back massively. Let's prompt and while our prompt and while our agents cook, let's review the codebase and then review their work. As we work through these, we'll address shortcomings, trade-offs and improvements we can make to this version of this Outloop system. And we'll discuss how you can move toward the next scale of Agentic coding. We are approaching the edge. These are the advanced lessons to the ideas here haven't arrived yet. but I wanna give you the greatest edge I possibly can. So let's get started and hand off more work than ever with the new agentic layer of new agentic layer of our codebase. As you can see here, we have our dedicated agent environment up and running. The webhook trigger is ready for prompts coming in from GitHub issues, which is our prompt input from our Peter framework. We've templated our engineering. We're operating out the loop so we can scale our impact as easily as copying a file. Let me open up our agent environment. You can see this is a screen If I run Chrome, you can see refresh, refresh. You can see our codebase, right? Classic natural language SQL interface. What we're going to do here going to do here is rapidly enhance this application. Okay, our agents know how to operate this codebase. Let's put them to work. So we have code open here. We have our web hook ready to go. Remove focus, open up GitHub issues. because this is our prompt source. Remember the Peter framework, you have prompt input, your trigger environment, and your review system. Our prompt input is of course, GitHub issues. Let's go ahead and fire up two, three, four, five pieces of work that will run end to end. Let's go ahead and run like various levels run like various levels of difficulty. So here I want increase drag and drop surface area. Paste all this in, feature, software developer lifecycle, isolated. We'll break this all down in just a moment here. And you can see the prompt. We want to increase the drop zone of the surface area so that we can drag and drop over any element. Feature two, I want JSON export. There's the prompt. You can see nice, simple, high-level prompt. Our agents handle the rest. I want the ability to create random data based create random data based on the existing schema in our table. So I wanna be able to click on a table and have it generate some additional random data for us to work with, all right? So this is another feature that you might get requested from your PM or something you wanna build into your product. And now you can have your agents do this and multiple other features at scale in parallel. We have a more mid-level prompt here. You can see there's a lot more detail. Feel free to pause and understand what's going on, but it's as you would expect, right? We want synthetic data based on the existing table patterns and schemas. We want support schemas. We want support for better models for query generation, all right? This is a simple one. This is gonna be a chore and we want to update our model to use 04 mini, okay? So we're just boosting our model. I think currently it's up to GPT 4.1. These are just random examples of work you might be doing inside of your code base that you don't need to do anymore. You can hand out this work to your agents, all right? And last but not least, let's solve a bug. We have a really simple issue here. If we open up this on the server, you can see here our products CSV export looks products CSV export looks like this. We have the chart icon and then CSV, but if we select a product, you'll see something here We have mismatched text. Okay, so this is just a small, simple bug. So we wanna align this. This is gonna be a simple high level prompt. And here we're not even gonna use the full SDLC workflow, which I'll break down in a moment. We're going to use a simple patch workflow. Okay, so check this out, five issues. We're gonna fire them all off back to back. Our Outloop agentic system is gonna pick up all these events up all these events and fire them off and get to work for us one by one. We've learned to stay out the loop. Let's kick this off. and we'll make sure that our agent is picking up these events. So we'll hop over to the screen. If we open up code, you can see the events coming in, our agent, as full control over this device. And we'll break down this work here in just a moment. Okay. And of course we have high level logging coming into our review system where our agents are ADWs. They're updating this issue live with the issue live with the events coming in. So let's continue. Let's scale up what we can do, right? We've templated our engineering. We've digitized our engineering into our agentic layer. Move to the next task. We'll fire this off. And the same thing will happen here, right? If we just wait for a second, we're going to get a nice response. There it is classified and the work is beginning. Let's go ahead, move to our big feature. You'll notice something important here. This is going to run SDLC, but we're using model set heavy. I'll break this down in a moment. Let's kick this off. Let's wait for our workflow here to respond. This should just take a couple of seconds. There we go. High level breakdown. go. High level breakdown. Let's continue shipping. Feature after feature in parallel, right? With our rich agent workflows. This is absurd levels of scale. Let's go ahead. That one's kicked off. CSV doesn't match. ADW patch ISO. This is gonna be a bug. Fine, let's kick it off. There we go. Patch workflow base model set. Fantastic. So we have not one issue, not two issues, three, four, five issues. Getting tackled by our agentic pipelines, right? By our AI right? By our AI developer workflows. This is all happening in parallel. We have encoded our engineering, right? We've templated our engineering into the agentic layer of our codebase. So now it operates for us. The next best thing we can do, right? There's gonna be a lot of background, right? A lot of waiting, a lot of reviewing. Let's understand the key changes that were made to our natural language codebase here. And let's break down the agentic layer, right? This is the important piece. As you can see here, we're operating on the simple application, but that's not what this is about. These ideas, everything we've talked about, every single tactic, it every single tactic, it scales to your code base. You're wrapping your codebase in a new agentic layer that operates your codebase on your behalf, okay? As usual, we're going to open up the terminal and we're going to clone in the less than seven code base. Git clone, CD into text seven. And I'll fire up code right here. We're gonna run our normal usual workflow. So I'm gonna fire up Claude in yellow mode. I'm gonna run slash install. You know this workflow, we've been doing it back to back to back. We don't do this hands-on simple work anymore. Our agents do all Our agents do all of it for us. If there's something missing in your usual developer workflow, you embedded inside the agentic layer of your codebase, all right? Let's recap the key pieces of our agentic layer. The top level, the highest compositional unit, the best place to start is ADWs. And so you notice here, we have several additional workflows. The most important one being this, ADW SDLC ISO, Software Developer Lifecycle Isolated. And just below this, we have SDLC ZTE ISO. have SDLC ZTE ISO. We're gonna break that down later on in this lesson. Let's focus on that last additional piece. We have ADW Ship ISO. Let's focus in on the key piece here. We have end to end agents shipping work on our behalf the way we would. So let's open this file up. And as you know, the ADW directory is a scripting layer that lets us construct pipelines of agents that solve specific classes of problems back to back to back. Okay. Not all of our workflows are going to work perfectly end to end and that's to end and that's fine. The point is that we're leaning toward the future. We're working toward that future where we are operating out the loop more and more and more. Okay, this isn't black and white. It's not in loop versus out loop. It's in loop moving toward out loop. Okay, one day at a time, improving your workflows, improving your AI developer workflows down to the prompt level. Okay, you can imagine what this does. This is the complete software developer lifecycle, right? And it runs in isolation. Plan, build, test, review, document. We have this entire workflow and this is what and this is what we fired off on most of our runs here, right? ADW, SDLC, SDLC, SDLC, SDLC here. And then here is the only one where we did in patch. All right, just a simple cleanup, right? It's just text. We don't need to go all into the SDLC to solve this problem. Although if you wanted to, you could. This is the SDLC. This is the software developer lifecycle end to end. This is what we've been building up to, all right? This is full automation across the software developer lifecycle. There are many different flavors of this. You're going to want to tweak it and make it your own, but this is own, but this is an incredible starting point for the agentic layer of our codebase. Now let's just focus on the key pieces here. We have several flags and ideas embedded, but what we want to focus on here So if I just search this plus that Python, let's enable regex. You can see we're just kicking off lower level compositional pieces, right? This is not new. We start by planning, we then build, we then test. You can see we're skipping end to end here just to save some time. Then we review our work. And then of course we document the work done. This is work done. This is just a full recap of everything we've done up to this lesson, right? Now, the interesting part here is how we've scaled this up. Before, as you'll remember, our agent box was limited to strictly operating in the base directory, but now we've used Git work trees. And it doesn't matter that you use Git work trees. It doesn't matter if you want to use individual instances, individual VMs, Docker containers. I don't care how you scale up your agent environments, it only matters environments, it only matters that you can, all right? So we've adjusted all of our workflows to create their own isolated trees. Check this out. In every tree, right, in every one of these directories, the application exists for a specific agent to build in. This is the easiest way to parallelize your workflows and to scale up agents into your work. You can see we have all of our environment variables, our playwright configuration at the beginning of our workflow. And we can of course just search this, right? Because we know how to navigate the agentic layer slash install work. You can see here in plan see here in plan ISO, right? When we're planning our work, setting up the environment, we run slash install work tree. And then we're passing in our ports that were created and our work tree path. And then you can imagine what this does, the work tree, sets up every piece that we need to operate the codebase in a dedicated directory, right? So we're basically cloning in a new version. We're installing as if we, the engineer, were operating, right? This is critical. Some type of configuration format like this is going to be really important. A lot of engineers, you're going to lean on tools like Docker, some new agent-based containerization frameworks. Whatever you use doesn't matter. Don't get caught on that. Get caught on scaling up the agentic layer so that you can multiply your agents. You want agents operating in parallel, in dedicated isolated, safe environments. Okay. And then you want to be able to quickly plug in to any one of these environments, right? At any moment in time, I can come into one of these work trees, right? So say I wanted to, I can do something like this, right? At any moment in time, I can come in and I can say code trees, can say code trees, 8F. Let's actually use a real, let's use a real ID. So we have this agent operating here and this agent just implemented its solution. So if we copy this ID here, we can open up this agent environment right now. And we can just watch what's going on. So we open up this, we have a brand new instance, we're in the dedicated environment that this agent is operating in. Check this out. You can see the branch down there, right? Chore task issue 39, there's the ADWID. Okay. Think in the gray, we're not jumping to Outloop. We're progressively handing off more and more work to and more work to our agents. All right. So things are going to go wrong. We're going to need to hop in the environment, understand what went wrong with our agents so that we can not fix the issue directly, but so that we can hop up to our top level and improve the agentic layer of our codebase. I hope you can see the theme here. We're building the system that builds the system. We're not solving the problem directly anymore. Of course, we will be doing that, right? Your domain specific problem is everything, but the impact you can have, the rate in which you can solve your specific problem can now be drastically scaled up when drastically scaled up when you put your effort into your agentic layer, right? And that top layer, the top surface layer of that is of course your AI developer workflows. And then once you work down, the lower levels you get to your individual prompts and the details of you know your agentic prompts and how they work and how things compose back up to your ai developer workflow level that's super key really important to be able to dive into an environment that's git work trees that's how we're using them here to parallelize our workflows it's also important to mention that the lesson six tactic has lesson six tactic has not been broken this is really important for scaling we have one agent running one prompt with a single purpose now In order to combat some of the state management issues that you're going to run into, we do have this state.json object, and we're starting to track more and more information here, kind of meta information to pass through to your ADWs and to your individual agents. expect to have to add some type of state object inside your dedicated agent environments, but this truly frees your this truly frees your agent to do one thing extraordinarily well with all the context it needs and it lets you jump in and replay what that agent has done. Right? So this is super, super important. So let's hop back up to the top level. Let's see how our agents are doing. Our add JSON export agent, if we scroll to the bottom here, it looks like we're in the review phase and you can always just scroll up and see the current state object tracking everything that we need to see at a, you know, review level. That's looking great there. What about our drag and about our drag and drop? Looks like we are isolated implementation phase complete. Nice tests have all passed. Fantastic. Final test. So we're probably reviewing now. Yep. Okay, great. Also reviewing here. Here's our table random data generation feature and more mid-level prompt here. And we're using the heavy model set. This is important. Let's talk about the heavy model set for a second. If I scroll down here, it is okay. Implementing the solution. This is probably the largest feature that we're shipping right now or that our agents are shipping for us right now. Let's go ahead and understand what model set understand what model set is. We're adding a knob to our capabilities, right? You can encode any information dense keyword that you want. You just have to make sure that your prompts recognize it and pick it up. What do I mean by that? Of course, you know that an IDK is an information dense keyword. These are keywords that affect your agents, right? They affect your prompts. We've encoded this into our prompts into our ADW. So What does this model set have you do? We know that we can specify features, chores, bugs, and we can select our AI developer workflow. But of course, you're going to want to pass in more information into in more information into your workflows. You're gonna wanna tweak some of the agentic variables, and this is one of them. So what does this do? Our model set changes the set of models that runs against our workflow. This is very simple. If we open up agents.py, we're gonna get to our agents file and you can see exactly what this does, right? We have a map between our custom slash commands, right? Our prompts that run our agents and every one of them maps to either a base model or a heavy model, right? And you can see here in some of our heavy models, right? Heavy forward opus, we Heavy forward opus, we are running a beefed up model. So this is all that this does, right? It gives us a little knob to turn to increase the compute that our workflow uses, right? In this case, by compute, I specifically mean the model that we're using, all right? So exact same prompts, exact same reasoning when it's called out. Inside of our prompts, we of course have the, let's go to our chore.md, right? If you just search think, you can see we have the encoded think hard information dense keyword. This is fantastic. You can find this, you know, all over. you know, all over. If we just do a search for this inside of all of our prompts, this is important for activating your reasoning model. So we are scaling our compute there, but we have an additional knob here to scale it again. So if we pass in heavy and the workflow that detects this is going to be our classify ADW, right? And again, if you're ever wondering where this stuff runs, you can always just type slash classify ADW. Okay, and so it runs right here, workflow operations, where we classify the ADW at the beginning of the workflow. To obtain this JSON object. We this JSON object. We wanna parse out the base model, ADWID, and of course our slash command that we're going to run. And this is one of the first things that runs in our workflows so that we can parse this information out, right? And so we've encoded this and you can see we just use base or heavy, right? Super important idea here. You can encode any information dense keyword you want that changes your workflows, right? And you're likely gonna wanna pass those in at the top level to adjust how your agents operate a given task or feature. That's that. Let's feature. That's that. Let's see how we're doing here now. Okay, so we're still implementing. This is a heavy feature and we are running heavy models, right? So this will take some time. Looks like we're 11 minutes in right now. Let's continue to our other features. See how we're doing. SDLC, updating model. We wanna use that 04 many for our SQL natural language generation functionality. So let's go over to the bottom here. Awesome, so check this out. Six minutes ago, this feature completed. Let's scroll up to our review. This looks good. All tests passed. We updated from 4.1, 04 many, it looks great. Fantastic. And we of course And we of course have a PR so we can open this PR up here. 100 lines change here. This is a simple change. Let's see what we changed here. Our conditional docs, of course, agentically was updated. You can see there's that key change, LLM processor. Our model is getting bumped. It's getting bumped there. So wherever we're calling our OpenAI model, it's getting bumped. Our tests have updated. So we have a nice set of documentation here. We're referencing the original plan, right? We have documentation and we have the plan. So we have both ends of the software developer lifecycle. We software developer lifecycle. We can see it all. We can understand what our agent was looking at when it created some things. And then we also have our spec file, of course, which details out this chore, relevant files. New files, step-by-step, breakdown, blah, blah, blah, blah, blah. We've covered all this. We know how planning, building, testing, reviewing, and documenting works, right? The great part is, is that we're seeing it working all together now. right? Digitized our engineering, just like we can copy and paste a file, we can copy and paste our engineering across agents. This is the power of the the power of the Outloop system. This is the power of investing in your agentic layer of your codebase. This is where scaled up agentic impact happens. Now, many engineers are going to gloss over this. They're not going to pay attention to this. They're going to stay in the loop and they're going to waste a bunch of time. Not you and I. CSV text doesn't match. This is a simple patch workflow. It looks like this completed a while ago. Great. So you do want to stay on the review system as much as possible, right? You want to build up your review system to be intricate, to be detailed so that basically you don't have to leave to know that leave to know that your agents have shipped the work end to end. Here, we're just using, you know, GitHub issues. We're posting literally right back to the issue that kicked off the workflow. A lot of engineers, you know, you're going to want to look at the pull request. You're going to want to push content information to the pull request. I do think that this is an entire product category that is important to build out. Having a comprehensive review system is a massive, massive edge for increasing your review velocity. Right here, you can see, you know, throughout tech, we're keeping it simple. We're showcasing concepts, ideas, tactics, right? concepts, ideas, tactics, right? By just using existing technology, you can spin this up and get started right away. But it's important to note that the review system is critical for increasing your agent engineering velocity for the review step. Concretely, We should have a feature now that here we go. That's completed. It's it's review. Okay. Now check this out, right? This is the power of great review. This is critical, right? Here's the review summary enhance drag and drop feature for both query and table selection. So check this out. Our agents. Took images and gave us proof that the feature has that the feature has shipped. Check this out, right? Drag and drop. We now have this overlay right here. We have this overlay right here, right? Drop to create a table. And our screenshot for its regression testing, making sure that everything looks good. This is beautiful. Agents, they're operating like you or I would, right? This is what it means to have a powerful agentic layer, right? They've uploaded screenshots. It's proof of value. Remember what the review step answers. It's not, does it work? It's is what we built, what we asked for. And you can see here, this is exactly what we asked for in we asked for in the prompt. Drag and drop over any block that exists, right? Drag and drop feature has almost been completed. So remember, we fired this off 27 minutes ago, and I wonder how much code we're gonna get here generated for us by our agents, maybe two, 300 lines. Yeah, nice, 300 lines. Okay, fantastic. That looks great. And so our other agent here, add.json export, looks like it's working through the review. Looks like it found a blocking issue during the review phase. So now it's going to try to fix this, so that's great. And our random data is our random data is still implementing. This is a big feature, it's running Opus. This is gonna be the ones where we might have to jump in, right? Go from Outloop to Endloop to kind of round out the implementation or understand what's going on. Our increase drop zone surface area has completed. This is fantastic. So all the work here is done and that means that we can check out the PR. So let's go ahead and open up this PR. I'm going to copy the branch Looks like we have 400 lines here. That's great. And now we're going to do some hands on review, right? Some in loop review. Some in loop review. Okay. So this is still going to happen. As much as I'm pushing and advising you to go out the loop, right? You want to stay out the loop. I understand that it's important to keep in mind. Engineering is not black and white. It's gray. You progress toward the next thing, right? You progress toward Agentic Engineering. You progress toward using tactics of agentic coding one day at a time. Right? It's not black and white. Okay. It's not that simple. It's not that stupid, right? What we're doing here is quite complex. And so what we're going to do here is go in the loop and review this code. All right. So our agents right. So our agents have proved to us that this feature is built. The review step is super, super critical for this. Remember we have this concrete review. So our agents have proven to us that this works, but you know, we're engineers, we're skeptical. We're getting used to this. Our installation has worked. We do need to reset the origin. So of course I'm gonna do that real quick here. Set origin back to tag seven. Of course, you will create a new codebase so that you have access to a full GitHub repository codebase, but I'm just gonna do this here. Fantastic. Now I'm gonna stop that. And gonna stop that. And now I'm gonna run a new prompt in loop review. All we do here is pass in our branch, pop the branch name, pass this in and our in loop review. Of course, you can always just look at what the prompt is doing. and the preview, you can see here, it's nice and simple, right? Pull the branch, grab the changes, reset our database, restart the application, let's review, right? So this is super simple. We can even, you know, check out back to main and reset when we're done here, right? So you can see we are on that new branch. And that new branch. And we should get the browser open up pretty soon. You can see we have open here, fire it up for us on our local host on this device, right? My machine here. I'm using my resources to validate my agent's work. Stop apps, reset database, start in the background. And now we're gonna open up the browser. Don't do this hands-on manual engineering work. Teach your agent how to do it once and then run it over and over and over again and scale it across your team. Okay, there it is. This has popped open for us now. And remember we're testing our drag and drop feature. drag and drop feature. So I'm just going to move this right here. Select five users. We can fire that off. We'll of course get five users. We can hit upload. You can see previous items there. We can hit our event analytics. That events table got created. Great. We can, of course, delete it. Blah, blah, blah. Let's refresh. And now let's drag and drop over this UI, right? Cause that was that net new feature. We're just doing simple human in the loop testing here, drag and drop. Let's go and do that events.json. And yeah, let me move this a little bit so you can see this. That's not JSON. So check this out. Nice, clean drag out. Nice, clean drag and drop. Check that out. And down here as well, you can see that's working on both sections. Let's go ahead and drop it here. And look at that. We have our events table. I'll go ahead and delete products just so we can get some more table drops here. And let's open this up and we'll drag and drop products on the top. That was added and we don't have to keep going on with this, right? This is simple application level stuff, but you can see that this feature was built into Ant, okay? And not only did our agent build this for us, it proved to us that the work was done. Here are images and you are images and you can of course take this a step further. You can build any media review system that you need to for your agents to prove to you that the work is done, right? The next most obvious one to build out is video. Right? Have your agents take video, upload it to a cloud bucket, and then post the URLs right here on GitHub issues or whatever review system you want to use. Remember the Peter framework and get a great review, right? It's very clear that, you know, planning is important. Building is important. Testing is important. Review is especially important, right? It's proof of value. Like we talked about in our previous lesson, It lets your agents communicate to you is what was asked for what was built. Okay. And then we of course document it. We're going to have some documentation here. We can just quickly search that since we're on the branch or agent created that's app docs enhance drop zone. And now we have this documentation. It references the original spec, right? Our codebase is operating itself, right? It's documenting. It's referring to the original spec. The reason why we planned is much more than just to ship code, right? We have artifacts, right? We have artifacts, right? We have artifacts for agents. Okay. When you combine all of this with the conditional docs, we of course have our brand new feature enhanced drop zone updated in our conditional documentation. So now when our next agent runs, it knows that when it works with drag and drop implementing file upload, troubleshooting, blah, blah, blah, right? It knows that when it hits one of these conditions, Pull in this documentation. This lets our agents scale with the size of our codebase. Pull in the right documentation when it needs to. Focus on building the right thing when it needs to. And it needs to. And our agent is doing all this in its own isolated environment, in its own Git work tree, so that we can parallelize all this work up. This is big. Some of these other features, let me just take a quick look at these other features. JSON, there we go, check this out. We got our JSON there. That looks great. You know, we don't need to go through all these features, right? What I wanna communicate here as we start rounding out tactical agentic coding is that investing in the agentic layer of your codebase provides you with asymmetric results, okay? You can't vibe code this stuff. vibe code this stuff. Your agent is operating as you would. You've templated your engineering. You stay out the loop. You have one agent, one prompt, one purpose. All of these tactics stack up to give you some incredible result like this, right? Look at screenshot four, our agent is validating work, it's running prompts. This agent has taken over this device, it's taken over this engineering work. Why is that? It's because we invested in the agentic layer, okay? This is Agentic Engineering. We're building the system that builds the system, that builds the system, right? This is game changing and it all starts when you stop coding. This is not our domain anymore, okay? Coding, it's not our domain anymore. Agents are better at this than us. So leverage the agents, okay? We're continuing on the trend of just scaling our compute to the next level so that we can become commanders of compute. I can't stress this enough how important it is to invest in your agentic layer, okay? This is what the winners are doing. I parallelized myself across five features, right? We're shipping, features, right? We're shipping, we're shipping end to end. Check out this workflow. This is a 27 minute heavy model workflow that is building out table random data generation. This problem, this engineering problem could be anything. When we look back at all this, let me just pause here for a moment. Let's just talk about what we're doing here. When the agents arrived, Something changed. We weren't just AI coding anymore. We started orchestrating intelligence. We're going to look back at this time and think that. And you want to be you want to be ahead of this curve, right? You want to be pushing forward, lean into this, okay? You want to get these gains before anyone else does, right? This is technology. It always gets distributed, right? But you want to be at the edge so that you can get the gains as long as possible, right? I'm giving you an information arbitrage, okay? You have an information edge now. And then the question is, are you going to use it? to invest in the agentic layer, right? This is what it all comes down to, okay? This is ultra, ultra important stuff. So the next natural question is, right? It's question is, right? It's not enough to push it to the edge. Let's go beyond the edge. What happens next, right? What happens after your agents are, look at this, right? Your agents are testing for us, pie test, found an issue, five failed tests. Now it's going to resolve these issues. What happens when we get so good at this that just like you saw here with our drag and drop feature, Your agent ships end to end and me reviewing obviously is important here for us. But imagine you do this for the 10th time you shipped a time you shipped a chore or bug or even a feature end to end. What happens next, right? When you get so good, when you template your engineering so well in your codebase, something will happen. Okay. I want to zero in on this idea here. Something is going to happen once you become proficient at Outloop agentic coding. You'll realize something incredible. This human in the loop model is a bottleneck. I'm not catching any bugs anymore. I'm not adding any value outside of the agentic layer. I'm going to remove the human in the loop review process for this class of for this class of problems. Once you come to this realization, and trust me, if you bet big and invest in your agentic layer, this will happen. You will arrive at the next order of magnitude the Agentic Engineering velocity scale first we're in the loop next we're out the loop and then we're doing z t e zero touch engineering you'll drop yourself off the end of the Outloop Peter framework and it becomes Pete not Peter you'll drop off the review, okay? This is the next This is the next step. Let me just be super clear about what this is. This is YOLO mode for your AI developer workflows. This is high confidence mode for agenting engineering. It's maximum confidence mode for agenting engineering. No review, right? Just like you've stopped coding, you'll stop reviewing. This is the lesson seven tactic. Target zero touch engineering. This is the ultimate agentic coding Northstar. This is what your agentic coding KPIs lead you toward. Attempts at one, size constantly scaling up, size constantly scaling up, streak constantly increasing as you solve and ship problem classes back to back to back with one attempt and you'll drop your presence down to one. You'll let your agent ship end to end. When you do this, you've achieved zero touch. Engineering. The best Outloop agent decoders have a presence of two. You show up at the prompt and you show up at the review, just like we were here, right? Our presence for this drag and drop feature was two. Okay. We increased it by going into the loop, but we only needed two, we only needed two, right? Prompt and review. In the future, you'll realize that you're wasting time Reviewing. I know you're probably O-faced right now or thinking the O-face or maybe right away you just went, Dan, absolutely no way, that's crazy. This isn't a real production application. What you're doing is you're operating on a toy app, you're pushing way too far. This is a pie in the sky dream. I get that. I understand. Let's slow it down a little bit. Okay. You don't start by shipping a full feature, right? I'm not saying go into your production application, spend all your time on one agentic time on one agentic workflow and ship features to production, right? That's not what I'm saying here. Progress happens one step at a time, one day at a time. First, go after chores, then go after bugs, then go after features, right? Scale it up, solve these stupid, simple problems that waste your time. You know what they are. You've already thought of them as you're working throughout tech. You've already thought of things you want to augment and automate, then scale scale it up one step at a time, okay? This is ultra important. We'll fire one of these off in just a moment. If I open up the codebase, let's get back to main. So I'm gonna main. So I'm gonna run slash and loop and let's go back to main. In the beginning, I mentioned we have this new workflow, ZTE. All ZTE does, this will run the exact same workflow as SDLC and then it adds one more thing and you know what's coming, right? We've hinted at this already. It is going to run ship, approve and merge the PR agentically. If nothing fails here, if your agents get through your engineering pipeline and they've proven to you, great review with great tests, that the feature is working and you've run this over and over and over, the over and over, the next step, is ZTE, let them ship to production. And ship does exactly what you think it does. It doesn't really matter how you do this. You can do it however you want. Just to express the point here, our ship command is just gonna check out main on the root repository outside of the tree. It's going to merge in the feature branch and then it's gonna pose success. That's it. So just close the PR, push the work into production, deploy the pipeline, ship. And the whole point here is we're going to do something small, right? We're going to start small because this is the best place to start with Tactical Agentic Coding. with Tactical Agentic Coding. Start small, solve a small problem set, and then scale it up, okay? Especially for zero-touch engineering. So let's say that you need to update the background color of your website or update some styles, right? Something simple, right? Frontend is a great example because frontend is simple. If you build it right, it should be simple. Styles, components, APIs. This is just, of course, a micro example. I just want to stress the point in your background color, update, Torque, ADW, SDLC, ZTE, Zero Touch Engineering, ISO, Zero Touch Engineering, ISO, update, light green, Let's just say your designer is having a bad day, whatever, they wanna update some random styling. They've decided that glass is the new big thing or whatever UI is the next big thing, right? This is not something you should ever spend your time on, right? This is not engineering. So hand it off to your agents, right? This is low hanging fruit. Your agent should be able to ship this end to end. Let's kick this off and let's get a ZTE execution. In a couple seconds here, we're gonna get our initiation. Just gonna detect that this is a zero touch engineering workflow. And you can workflow. And you can see here, right? We get this important message here this workflow does all of this for us, right? And this is the key, plan, build, test, review, generate, ship. This is where it all ends up. And yes, we're looking at primitive versions of this. Yes, it's a simple thing to do, but yes, this is still critically important. ZTE, zero touch engineering. We're starting out with the plan phase. It'll run a little bit faster because this is just a chore running our base model set, but you get the idea, right? So this is not worth watching. Let me just talk about this idea a bit more. And then let's more. And then let's talk about the secret of tactical, logistic coding. What has this all been leading up to? You can see here, we've built up to these incredible Outloop systems. Our codebase is running itself and we're coming in to make sure things look good. We're spending our time, building the system that builds a system. And I know a lot of engineers, when you look at the zero touch engineering scale of agent decoding, you might think that this is impossible. There's no way you're letting agents ship to production in your real production application, right? Yes, I completely agree with you. We're operating on a simple toy application. There's no real application. There's no real risk here, but that's all missing the point, right? I get that real code basis have a lot more complexity, a lot more code, a lot more wear and tear legacy code, code debt, blah, blah, blah. Okay. I get it. I've been doing this for over a decade and a half. Okay. I know how these systems look. I know how they work. Let me just provide you with a concrete counter narrative for you to help you push into the future and not stick with the current narrative. This doesn't happen all at once, right? Like I mentioned, we build this out. one piece at a time, okay? We're in time, okay? We're in the age of agents. This is phase two. So let's act like it. Prepare for agentic coding capabilities to go parabolic, okay? How do we do this? We build the agentic layer into your codebase. Here's a really, really important question to ask yourself. As models continue to improve, as tools continue to progress and become more capable, who knows what the next cloud code like leap is going to be? If you don't invest into the agentic layer of your codebase, you know when agents can solve your problem class that you're working class that you're working on end to end with no oversight? How else will you know unless you're trying to do this? Okay. I can guarantee you right now, you are doing engineering work you do not have to do. I can tell you that as a fact. Okay. Unless you're one of the one fractions of a percent of engineer that likely have already been following a lot of my work, there is work that you are just doing that you do not need to do. Everything starts small and then it compounds. Your first agent should ship a class of chores that you know you can ship over and over, right? Simple stuff like right? Simple stuff like this, front-end changes, database migrations, right? Simple, low effort, easy to validate, easy to test, encode your engineering, template your engineering, let your agentic system, let your ADWs prove to you that they can do this work, right? That's your responsibility to encode that into the agentic layer. Everything starts small, think in the gray, but once you start down this path, you realize something very quickly, it will compound. Your first agent ships a chore, your next agent Agentec workflows, start shipping bugs, then features, and then they'll do it five times and they'll do times and they'll do it 20 times and then they'll do it. Here's the important part five times in a row. And you'll realize that you add no value by reviewing. In fact, you slowed things down. And this is the key. Of course, here in tactical Agentecoding, you and I, we're not focused on the present. We're not focused on the past. We want to be on that in that sweet spot, leaning toward the future. Here's a great visual for you. The future is coming at you at a constant pace. You have three options really four options you can neglect the change and just run away do it the old way go in old way go in the loop stay in the loop fine you can stand still let the future come to you this is faster than running away right you don't disagree with the future but you're not doing anything about it fine obviously that's not us right then you can move toward the future as it's coming toward you you move toward the future this is powerful this is where you want to be or you can take everything we've done here and sprint sprint toward the future of engineering. Beat everyone else there. Get this agent declare in your codebase. Get this up and running. Have agents building for you. Build a system that builds a system. This builds a system. This gets you to an incredible place. And this is like a simple, simple comparison, right? Imagine an engineer that runs toward the future, right? They set up agents in the codebase to solve problem classes. At the end of the day, a couple of weeks, maybe a month of investment, right? Probably not. You probably don't need that. But, you know, let's say a week to a few weeks of investing in your agent declare. Over time, all of a sudden, they have 90% confidence that a whole class of chores or bugs will ship with minimal risk. They write a single prompt, hit enter and ship hit enter and ship into production. Zero touch engineering. 90% of the time, there's no issues. And that number keeps going up. Every tool release, every model release, every time they improve their organic layer. Okay. Now imagine the other scenario. Let's say you're standing still or you're moving away, right? Say you're running away. You open up the terminal, you look at JIRA, right? You look at your task management tool, you pull it up in your in-loop IDE. Hopefully you're using cloud code, but if you're not on board with some of these ideas, you're probably maybe not even using it, right? Maybe you don't use an agent at all. You write the prompt, you sit, you wait, you sit, you wait, you iterate, you retest, and you do all this stupid stuff that you can have your agents do. Okay, tell me who wins this. Tell me who makes their business more money. Tell me which engineer is better. Okay. I'm getting like getting super into this because it's so important. This is it guys. This is, this is the peak. This is the pinnacle. This is the change that you have to make, right? There's the code. There's the ADWs, right? We're going to break things down. We're going to go from the compositional level up to concrete examples in lesson eight, but we're going to round things out in a fantastic fashion. But the real fashion. But the real thing, the real hurdle, the challenge of tactical agentic coding is about your belief You have to believe that the agentic layer is worth investing into you. You have to trust me. You have to invest into this, okay? If you don't believe that your agents can run your codebase, you're cooked, all right? I can't be any more blunt than I am here. I'm trying to give you everything you need here, okay? If you think that zero-touch engineering is in the far future for you, that's fine. You know what? You might be what? You might be right, but it's not about being right. It's about being prepared to win. It's about thinking in the gray so that you can get the gains as soon as they're available. This is not a black and white thing. It's not on and off. It's progression. It's improvement. It's iteration. You know this. You're an engineer. So hopefully that monologue was useful for you. Let's come full circle here. If you do all this, if you ride this curve, if you even get to out loop, right? And you start progressing towards zero touch engineering, I promise you, if you do this right, you will be the engineer engineer they can't replace. Why is that? It's because you understand and because you understand and control the agentic layer of your codebase. This is the area of highest leverage. I don't think it's far-fetched at all to say you'll get exponential leverage by allowing agents to run your codebase and by templating your engineering. Okay. I don't think that's far-fetched at all. And I mean this from a brute objective career defensibility standpoint, from a tactical angle, you'll understand this technology so well that it would be crazy for anyone in your organization, anyone on your team to conceive of letting to conceive of letting you go. It'll be the opposite, right? They'll be scrambling to try to keep you around and try to spread your principles of AI coding and spread your tactics of Agentic coding to your team. Not only is this extremely great, right? Moving up the stack, wielding more compute in parallel. Not only is this great for your career and defensibility and, you know, advancement, but you're going to send your engineering team to the next level and therefore your company, right? The tech industry, VCs, talking heads, they're all wondering where the big AI gains will come from. They're will come from. They're wondering what's all the capex spend for. I've known this answer from the beginning. It's not AGI, it's not ASI, right? Since the beginning, since GPT 3.5, when I saw this technology and started moving ahead of the curve, I knew the answer from the beginning. It's you, the engineer with their boots on the ground, solving one problem at a time, shipping real value, using AI like no one else can, using compute like no one else can, except the The problem, and this is the tricky part, focusing on the right problem is key. right problem is key. The problem you're solving is one that lets you scale your capabilities beyond imagination with agents. What's the cost? What's the trick? Here in TAC7, you have everything you need to win. The next step is just to invest and master the agentic layer. That's it. This is your moment. If you do this right, it will change everything. This is the most important lesson in tech from a beliefs perspective. You have to believe that this is the right direction to go. Before we reveal the secret of Tactical Agentic Coding, of Tactical Agentic Coding, let's just review our Zero Touch Engineering workflow here. It should almost be shipped by now. This is a simple feature. We're on the documentation step, so we're almost there. You can see here, once again, our engineering has been encoded. We have screenshots in our review phase, in our review step. Background is green, right? Super, super simple, right? There's the validation one minute ago. Our agents are working for us. They're validating their work. This is a great example of something you can just ship to prod. There is no value in me doing this, right? There is this, right? There is no value in me reviewing this. So there we go. We just got the documentation phase. And in a moment here, this is going to ship all the way out to prod. In our case, prod is just pushing to the main branch. There's nothing very easy to see here, but for you, this will be your deploy, go to staging, go to production, however your engineering is configured. How are we going to round out tactical agent decoding, right? What has this all been about? Obviously here, you can see the trend. It's about the agentic layer, but let me just share the secret with you. Zero touch engineering is the next stage in the velocity scale. This is velocity scale. This is an advanced edge next level concept, but this is something you wanna be working toward. This is the tactic of lesson seven. Target zero touch engineering. In the end, you want no overview, no oversight because it's been embedded into your agents, right? Your agents have gotten so good and your templates have gotten so great that your agents know how you would do the work. And you know, how is this possible? It's only possible because you've encoded your engineering. You've told your agents, you've instructed your system, you've trained your system to know when things are ready for production. Right, maybe you add another step on add another step on the software developer lifecycle. Maybe you've add that key deploy check step, bunch of deterministic deploy checks, whatever you want to do. Maybe you go super hard on your review step. Maybe you add video to review. Maybe you add double agent check, right? Maybe you parallelize the review step so that three agents have to say, three pipelines of agents have to say, this is right. You can run the fusion chain on agents. Okay, it doesn't matter, right? It really doesn't matter. And this leads us to the secret of Tactical Agentic Coding. This is what everything's been building up to. The secret of tactical agentic secret of tactical agentic coding is that it's not about the software developer lifecycle at all. It's about composable agentic primitives you can use to solve any engineering problem class. I'm just gonna say that again. The secret of tactical agentic coding is that it's not about the software developer lifecycle at all. It's about composable agentic primitives you can use to solve any engineering problem class. The software developer lifecycle is powerful, but it's a remnant of the past. It's been very powerful. It's still very relevant. It's something that we It's something that we bet big on, but there's no doubt in my mind, it is not the optimal way to run software with agents. This is a new paradigm of building arbitrary AI developer workflows that can and will outperform the software developer lifecycle. It's all about the composable pieces that you put together. It's going to look a bit different for every single organization and every single engineer. And yes, likely your AI developer workflows, right? Your end-to-end system will contain similar steps. Right, plan, build, test, review, document. But test, review, document. But my point here is, it's not about these steps. It's not about the software developer lifecycle. What we've done here is, throughout Tactical Agent Decoding, the key has been showing off how you can use and compose the new fundamental units of engineering to solve problem classes, right? Sets of problems. We're not solving one-off problems anymore. All we've been doing is showcasing what this could look like inside of the agentic layer of your code base, okay? Let me be super clear. I'm saying that this arrangement of ADWs is completely of ADWs is completely arbitrary. There is no one way to do this. The one way is the way that ships in your code base. This is just a starting point, right? This is a package for me to deliver a message to you. It's about how you organize your codebase. It's about always having feedback loops. Okay. We're not coding anymore, right? We've stopped coding because we've templated our engineering and our agents can ship on our behalf. When we ship, we adopt their perspective. And of course, when you put all this together, you can stay out the loop because you the loop because you have one agent, operating on one prompt with a single purpose. You have more precision while other engineers are trying to stack up into one context window. You're firing strongly defined specialized agents that execute one task at a time and hand off their work. You are composing, you are orchestrating intelligence. It's about the primitives. This is the secret of tactical agent decoding. Let's check our Zero Touch engineering workflow. And you can see here, it has been deployed it has been deployed to production, okay? The issue is closed. All I did was write this prompt. Update the background color. Of course, yes, it's like we've talked about. This is just a starting point. Agents can push more than this. They can do more than this, but it's all about progression, think in the gray and don't reject the ideas of the future. Target zero touch engineering. This is the tactic of lesson seven. This is your North Star when you are building out the agentic layer of your code base. In the back of your head, you wanna think, how can I build this so that I can gain confidence to one day confidence to one day run one prompt and have everything shipped to production. Don't run toward the future, don't walk toward it, sprint into the future. This is live, let's go ahead. You can see here's the blue color. I'm going to open a code, git pool, origin main, and look at that. Our agents shifted end to end. It's in production. This is zero touch engineering. This is the future of engineering. This is what happens when you use the tactics of agentic coding. All right, so coding. All right, so what happens next? Take a moment to just appreciate what we've done here. We have seen the future of where this is all going, right? We've transcended the traditional engineering velocity scale in loop, Outloop zero touch coding. You understand that the agent layer is the highest leverage point in your code base. This is the place where one X input becomes 10 X output and 10 X input becomes 100 X if you invest in this layer, okay? everything I've shown you, everything we've worked through in TAC so far, the plan, build, test, review, and document is just and document is just one way to compose agentic primitives. The software developer lifecycle we've been using is powerful. It works, but it's a package for me to deliver a message to you. The real secret is that it's about the composable units, the agentic primitives, all the way down to the prompt level, all the way down to cloud code, all the way up to how you organize your codebase, how you add tests, documentation, how you add types, and how you build up prompts, specs, plans, templates, and at the highest level, how you organize AI developer you organize AI developer workflows, ADWs. You'll want to resist this and you'll doubt that Outloop and ZTE are the future of engineering, but this is the crux of tactical agent decoding. This is the real challenge I have for you in this course. It's not about the code. The ideas are powerful, but the most important thing is that you must update your beliefs. This is a belief change that you must make for 10 to 100x scaled engineering with agents. And once you do this for yourself, something incredible will happen. Once you truly happen. Once you truly get this and start building it out, once you see the productivity gains, you're gonna have several aha moments and then you'll realize that you can unlock this value for your team and for your org. In-loop agent decoding is the lowest hanging fruit. Do not remain here. You are an engineer, not a coder. Build the system that builds the system and you will become an irreplaceable engineer. Focus on the agentic layer over everything else. Clear your schedule, tell your boss, tell your lead, tell your team, and most importantly, tell yourself, okay? Because if you do this if you do this right, it will change everything. What we're gonna do next in lesson eight, we're gonna blow this idea wide open, okay? The primitives are the atoms of agentic engineering. Master them and you can build any molecular structure you need. Think about what this means. Every codebase has unique problems. Every team has unique workflows. Every domain has unique challenges, but primitives remain constant and composable. In lesson eight, your final lesson, we're going to focus in on this. We're going to do two things. We're going to revisit the atoms to revisit the atoms of agentic coding, the new fundamental primitives of agentic coding that you can use. And then we're gonna look at compositions of them. We're going to scale up and we're going to look at different code base types with their own agentic layers, solving their own unique problems that you likely have encountered in your engineering. Okay. I'm going to give you many code bases you can use to explore, understand, and quick start your agentic coding of your agentic layer. Okay, you'll see how these primitives compose differently for web app, CLI tools, notebooks. Most CLI tools, notebooks. Most importantly, you'll understand how to jumpstart the process of building your agentic layer for your code base and your domain problem. And finally, we're gonna look beyond the edge right at the end of lesson eight. Just like in principled ad coding, we're gonna look at how we can best position ourselves to win today's engineering and tomorrow's engineering. Full recap, you've reached zero touch engineering. You now understand where this all goes from in loop to out loop to zero touch engineering you've discovered the secret, you have the full picture. As you close the As you close the loop on this course, as you close the loop on tactical agentic coding, you have to answer this question. Are you running away from the future? Are you standing still? Are you moving toward it? Or are you gonna join me and sprint toward the future with these tactics of agentic coding? Great work here. Thanks for following me through this. I hope everything makes sense to you. I'll see you at the edge in lesson eight.